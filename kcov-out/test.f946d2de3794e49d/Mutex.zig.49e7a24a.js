var data = {lines:[
{"lineNum":"    1","line":"//! Mutex is a synchronization primitive which enforces atomic access to a shared region of code known as the \"critical section\"."},
{"lineNum":"    2","line":"//! It does this by blocking ensuring only one thread is in the critical section at any given point in time by blocking the others."},
{"lineNum":"    3","line":"//! Mutex can be statically initialized and is at most `@sizeOf(u64)` large."},
{"lineNum":"    4","line":"//! Use `lock()` or `tryLock()` to enter the critical section and `unlock()` to leave it."},
{"lineNum":"    5","line":"//!"},
{"lineNum":"    6","line":"//! Example:"},
{"lineNum":"    7","line":"//! ```"},
{"lineNum":"    8","line":"//! var m = Mutex{};"},
{"lineNum":"    9","line":"//!"},
{"lineNum":"   10","line":"//! {"},
{"lineNum":"   11","line":"//!     m.lock();"},
{"lineNum":"   12","line":"//!     defer m.unlock();"},
{"lineNum":"   13","line":"//!     // ... critical section code"},
{"lineNum":"   14","line":"//! }"},
{"lineNum":"   15","line":"//!"},
{"lineNum":"   16","line":"//! if (m.tryLock()) {"},
{"lineNum":"   17","line":"//!     defer m.unlock();"},
{"lineNum":"   18","line":"//!     // ... critical section code"},
{"lineNum":"   19","line":"//! }"},
{"lineNum":"   20","line":"//! ```"},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"const std = @import(\"../std.zig\");"},
{"lineNum":"   23","line":"const builtin = @import(\"builtin\");"},
{"lineNum":"   24","line":"const Mutex = @This();"},
{"lineNum":"   25","line":""},
{"lineNum":"   26","line":"const os = std.os;"},
{"lineNum":"   27","line":"const assert = std.debug.assert;"},
{"lineNum":"   28","line":"const testing = std.testing;"},
{"lineNum":"   29","line":"const Atomic = std.atomic.Atomic;"},
{"lineNum":"   30","line":"const Thread = std.Thread;"},
{"lineNum":"   31","line":"const Futex = Thread.Futex;"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"impl: Impl = .{},"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"/// Tries to acquire the mutex without blocking the caller\'s thread."},
{"lineNum":"   36","line":"/// Returns `false` if the calling thread would have to block to acquire it."},
{"lineNum":"   37","line":"/// Otherwise, returns `true` and the caller should `unlock()` the Mutex to release it."},
{"lineNum":"   38","line":"pub fn tryLock(self: *Mutex) bool {","class":"lineCov","hits":"1","order":"498","possible_hits":"1",},
{"lineNum":"   39","line":"    return self.impl.tryLock();","class":"lineCov","hits":"2","order":"499","possible_hits":"2",},
{"lineNum":"   40","line":"}"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"/// Acquires the mutex, blocking the caller\'s thread until it can."},
{"lineNum":"   43","line":"/// It is undefined behavior if the mutex is already held by the caller\'s thread."},
{"lineNum":"   44","line":"/// Once acquired, call `unlock()` on the Mutex to release it."},
{"lineNum":"   45","line":"pub fn lock(self: *Mutex) void {","class":"lineCov","hits":"1","order":"753","possible_hits":"1",},
{"lineNum":"   46","line":"    self.impl.lock();","class":"lineCov","hits":"1","order":"754","possible_hits":"1",},
{"lineNum":"   47","line":"}"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"/// Releases the mutex which was previously acquired with `lock()` or `tryLock()`."},
{"lineNum":"   50","line":"/// It is undefined behavior if the mutex is unlocked from a different thread that it was locked from."},
{"lineNum":"   51","line":"pub fn unlock(self: *Mutex) void {","class":"lineCov","hits":"1","order":"556","possible_hits":"1",},
{"lineNum":"   52","line":"    self.impl.unlock();","class":"lineCov","hits":"1","order":"557","possible_hits":"1",},
{"lineNum":"   53","line":"}"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"const Impl = if (builtin.mode == .Debug and !builtin.single_threaded)"},
{"lineNum":"   56","line":"    DebugImpl"},
{"lineNum":"   57","line":"else"},
{"lineNum":"   58","line":"    ReleaseImpl;"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"const ReleaseImpl = if (builtin.single_threaded)"},
{"lineNum":"   61","line":"    SingleThreadedImpl"},
{"lineNum":"   62","line":"else if (builtin.os.tag == .windows)"},
{"lineNum":"   63","line":"    WindowsImpl"},
{"lineNum":"   64","line":"else if (builtin.os.tag.isDarwin())"},
{"lineNum":"   65","line":"    DarwinImpl"},
{"lineNum":"   66","line":"else"},
{"lineNum":"   67","line":"    FutexImpl;"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"const DebugImpl = struct {"},
{"lineNum":"   70","line":"    locking_thread: Atomic(Thread.Id) = Atomic(Thread.Id).init(0), // 0 means it\'s not locked."},
{"lineNum":"   71","line":"    impl: ReleaseImpl = .{},"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"    inline fn tryLock(self: *@This()) bool {"},
{"lineNum":"   74","line":"        const locking = self.impl.tryLock();","class":"lineCov","hits":"1","order":"500","possible_hits":"1",},
{"lineNum":"   75","line":"        if (locking) {","class":"lineCov","hits":"1","order":"512","possible_hits":"1",},
{"lineNum":"   76","line":"            self.locking_thread.store(Thread.getCurrentId(), .Unordered);","class":"lineCov","hits":"1","order":"513","possible_hits":"1",},
{"lineNum":"   77","line":"        }"},
{"lineNum":"   78","line":"        return locking;","class":"lineCov","hits":"1","order":"527","possible_hits":"1",},
{"lineNum":"   79","line":"    }"},
{"lineNum":"   80","line":""},
{"lineNum":"   81","line":"    inline fn lock(self: *@This()) void {"},
{"lineNum":"   82","line":"        const current_id = Thread.getCurrentId();","class":"lineCov","hits":"1","order":"755","possible_hits":"1",},
{"lineNum":"   83","line":"        if (self.locking_thread.load(.Unordered) == current_id and current_id != 0) {","class":"lineCov","hits":"1","order":"756","possible_hits":"1",},
{"lineNum":"   84","line":"            @panic(\"Deadlock detected\");","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   85","line":"        }"},
{"lineNum":"   86","line":"        self.impl.lock();","class":"lineCov","hits":"1","order":"757","possible_hits":"1",},
{"lineNum":"   87","line":"        self.locking_thread.store(current_id, .Unordered);","class":"lineCov","hits":"1","order":"760","possible_hits":"1",},
{"lineNum":"   88","line":"    }"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"    inline fn unlock(self: *@This()) void {"},
{"lineNum":"   91","line":"        assert(self.locking_thread.load(.Unordered) == Thread.getCurrentId());","class":"lineCov","hits":"2","order":"558","possible_hits":"2",},
{"lineNum":"   92","line":"        self.locking_thread.store(0, .Unordered);","class":"lineCov","hits":"1","order":"561","possible_hits":"1",},
{"lineNum":"   93","line":"        self.impl.unlock();","class":"lineCov","hits":"1","order":"562","possible_hits":"1",},
{"lineNum":"   94","line":"    }"},
{"lineNum":"   95","line":"};"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"const SingleThreadedImpl = struct {"},
{"lineNum":"   98","line":"    is_locked: bool = false,"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"    fn tryLock(self: *@This()) bool {"},
{"lineNum":"  101","line":"        if (self.is_locked) return false;"},
{"lineNum":"  102","line":"        self.is_locked = true;"},
{"lineNum":"  103","line":"        return true;"},
{"lineNum":"  104","line":"    }"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"    fn lock(self: *@This()) void {"},
{"lineNum":"  107","line":"        if (!self.tryLock()) {"},
{"lineNum":"  108","line":"            unreachable; // deadlock detected"},
{"lineNum":"  109","line":"        }"},
{"lineNum":"  110","line":"    }"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"    fn unlock(self: *@This()) void {"},
{"lineNum":"  113","line":"        assert(self.is_locked);"},
{"lineNum":"  114","line":"        self.is_locked = false;"},
{"lineNum":"  115","line":"    }"},
{"lineNum":"  116","line":"};"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"// SRWLOCK on windows is almost always faster than Futex solution."},
{"lineNum":"  119","line":"// It also implements an efficient Condition with requeue support for us."},
{"lineNum":"  120","line":"const WindowsImpl = struct {"},
{"lineNum":"  121","line":"    srwlock: os.windows.SRWLOCK = .{},"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":"    fn tryLock(self: *@This()) bool {"},
{"lineNum":"  124","line":"        return os.windows.kernel32.TryAcquireSRWLockExclusive(&self.srwlock) != os.windows.FALSE;"},
{"lineNum":"  125","line":"    }"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"    fn lock(self: *@This()) void {"},
{"lineNum":"  128","line":"        os.windows.kernel32.AcquireSRWLockExclusive(&self.srwlock);"},
{"lineNum":"  129","line":"    }"},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"    fn unlock(self: *@This()) void {"},
{"lineNum":"  132","line":"        os.windows.kernel32.ReleaseSRWLockExclusive(&self.srwlock);"},
{"lineNum":"  133","line":"    }"},
{"lineNum":"  134","line":"};"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"// os_unfair_lock on darwin supports priority inheritance and is generally faster than Futex solutions."},
{"lineNum":"  137","line":"const DarwinImpl = struct {"},
{"lineNum":"  138","line":"    oul: os.darwin.os_unfair_lock = .{},"},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"    fn tryLock(self: *@This()) bool {"},
{"lineNum":"  141","line":"        return os.darwin.os_unfair_lock_trylock(&self.oul);"},
{"lineNum":"  142","line":"    }"},
{"lineNum":"  143","line":""},
{"lineNum":"  144","line":"    fn lock(self: *@This()) void {"},
{"lineNum":"  145","line":"        os.darwin.os_unfair_lock_lock(&self.oul);"},
{"lineNum":"  146","line":"    }"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"    fn unlock(self: *@This()) void {"},
{"lineNum":"  149","line":"        os.darwin.os_unfair_lock_unlock(&self.oul);"},
{"lineNum":"  150","line":"    }"},
{"lineNum":"  151","line":"};"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"const FutexImpl = struct {"},
{"lineNum":"  154","line":"    state: Atomic(u32) = Atomic(u32).init(unlocked),"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"    const unlocked = 0b00;"},
{"lineNum":"  157","line":"    const locked = 0b01;"},
{"lineNum":"  158","line":"    const contended = 0b11; // must contain the `locked` bit for x86 optimization below"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"    fn tryLock(self: *@This()) bool {","class":"lineCov","hits":"1","order":"501","possible_hits":"1",},
{"lineNum":"  161","line":"        // Lock with compareAndSwap instead of tryCompareAndSwap to avoid reporting spurious CAS failure."},
{"lineNum":"  162","line":"        return self.lockFast(\"compareAndSwap\");","class":"lineCov","hits":"2","order":"502","possible_hits":"2",},
{"lineNum":"  163","line":"    }"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"    fn lock(self: *@This()) void {","class":"lineCov","hits":"1","order":"758","possible_hits":"1",},
{"lineNum":"  166","line":"        // Lock with tryCompareAndSwap instead of compareAndSwap due to being more inline-able on LL/SC archs like ARM."},
{"lineNum":"  167","line":"        if (!self.lockFast(\"tryCompareAndSwap\")) {","class":"lineCov","hits":"1","order":"759","possible_hits":"1",},
{"lineNum":"  168","line":"            self.lockSlow();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  169","line":"        }"},
{"lineNum":"  170","line":"    }"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"    inline fn lockFast(self: *@This(), comptime casFn: []const u8) bool {"},
{"lineNum":"  173","line":"        // On x86, use `lock bts` instead of `lock cmpxchg` as:"},
{"lineNum":"  174","line":"        // - they both seem to mark the cache-line as modified regardless: https://stackoverflow.com/a/63350048"},
{"lineNum":"  175","line":"        // - `lock bts` is smaller instruction-wise which makes it better for inlining"},
{"lineNum":"  176","line":"        if (comptime builtin.target.cpu.arch.isX86()) {"},
{"lineNum":"  177","line":"            const locked_bit = @ctz(@as(u32, locked));","class":"lineCov","hits":"2","order":"503","possible_hits":"2",},
{"lineNum":"  178","line":"            return self.state.bitSet(locked_bit, .Acquire) == 0;","class":"lineCov","hits":"4","order":"504","possible_hits":"4",},
{"lineNum":"  179","line":"        }"},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"        // Acquire barrier ensures grabbing the lock happens before the critical section"},
{"lineNum":"  182","line":"        // and that the previous lock holder\'s critical section happens before we grab the lock."},
{"lineNum":"  183","line":"        return @field(self.state, casFn)(unlocked, locked, .Acquire, .Monotonic) == null;"},
{"lineNum":"  184","line":"    }"},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"    fn lockSlow(self: *@This()) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  187","line":"        @setCold(true);"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"        // Avoid doing an atomic swap below if we already know the state is contended."},
{"lineNum":"  190","line":"        // An atomic swap unconditionally stores which marks the cache-line as modified unnecessarily."},
{"lineNum":"  191","line":"        if (self.state.load(.Monotonic) == contended) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  192","line":"            Futex.wait(&self.state, contended);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  193","line":"        }"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"        // Try to acquire the lock while also telling the existing lock holder that there are threads waiting."},
{"lineNum":"  196","line":"        //"},
{"lineNum":"  197","line":"        // Once we sleep on the Futex, we must acquire the mutex using `contended` rather than `locked`."},
{"lineNum":"  198","line":"        // If not, threads sleeping on the Futex wouldn\'t see the state change in unlock and potentially deadlock."},
{"lineNum":"  199","line":"        // The downside is that the last mutex unlocker will see `contended` and do an unnecessary Futex wake"},
{"lineNum":"  200","line":"        // but this is better than having to wake all waiting threads on mutex unlock."},
{"lineNum":"  201","line":"        //"},
{"lineNum":"  202","line":"        // Acquire barrier ensures grabbing the lock happens before the critical section"},
{"lineNum":"  203","line":"        // and that the previous lock holder\'s critical section happens before we grab the lock."},
{"lineNum":"  204","line":"        while (self.state.swap(contended, .Acquire) != unlocked) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  205","line":"            Futex.wait(&self.state, contended);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  206","line":"        }"},
{"lineNum":"  207","line":"    }"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"    fn unlock(self: *@This()) void {","class":"lineCov","hits":"1","order":"563","possible_hits":"1",},
{"lineNum":"  210","line":"        // Unlock the mutex and wake up a waiting thread if any."},
{"lineNum":"  211","line":"        //"},
{"lineNum":"  212","line":"        // A waiting thread will acquire with `contended` instead of `locked`"},
{"lineNum":"  213","line":"        // which ensures that it wakes up another thread on the next unlock()."},
{"lineNum":"  214","line":"        //"},
{"lineNum":"  215","line":"        // Release barrier ensures the critical section happens before we let go of the lock"},
{"lineNum":"  216","line":"        // and that our critical section happens before the next lock holder grabs the lock."},
{"lineNum":"  217","line":"        const state = self.state.swap(unlocked, .Release);","class":"lineCov","hits":"1","order":"564","possible_hits":"1",},
{"lineNum":"  218","line":"        assert(state != unlocked);","class":"lineCov","hits":"1","order":"566","possible_hits":"1",},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"        if (state == contended) {","class":"lineCov","hits":"1","order":"567","possible_hits":"1",},
{"lineNum":"  221","line":"            Futex.wake(&self.state, 1);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  222","line":"        }"},
{"lineNum":"  223","line":"    }"},
{"lineNum":"  224","line":"};"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"test \"Mutex - smoke test\" {"},
{"lineNum":"  227","line":"    var mutex = Mutex{};"},
{"lineNum":"  228","line":""},
{"lineNum":"  229","line":"    try testing.expect(mutex.tryLock());"},
{"lineNum":"  230","line":"    try testing.expect(!mutex.tryLock());"},
{"lineNum":"  231","line":"    mutex.unlock();"},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"    mutex.lock();"},
{"lineNum":"  234","line":"    try testing.expect(!mutex.tryLock());"},
{"lineNum":"  235","line":"    mutex.unlock();"},
{"lineNum":"  236","line":"}"},
{"lineNum":"  237","line":""},
{"lineNum":"  238","line":"// A counter which is incremented without atomic instructions"},
{"lineNum":"  239","line":"const NonAtomicCounter = struct {"},
{"lineNum":"  240","line":"    // direct u128 could maybe use xmm ops on x86 which are atomic"},
{"lineNum":"  241","line":"    value: [2]u64 = [_]u64{ 0, 0 },"},
{"lineNum":"  242","line":""},
{"lineNum":"  243","line":"    fn get(self: NonAtomicCounter) u128 {"},
{"lineNum":"  244","line":"        return @bitCast(u128, self.value);"},
{"lineNum":"  245","line":"    }"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":"    fn inc(self: *NonAtomicCounter) void {"},
{"lineNum":"  248","line":"        for (@bitCast([2]u64, self.get() + 1), 0..) |v, i| {"},
{"lineNum":"  249","line":"            @ptrCast(*volatile u64, &self.value[i]).* = v;"},
{"lineNum":"  250","line":"        }"},
{"lineNum":"  251","line":"    }"},
{"lineNum":"  252","line":"};"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"test \"Mutex - many uncontended\" {"},
{"lineNum":"  255","line":"    // This test requires spawning threads."},
{"lineNum":"  256","line":"    if (builtin.single_threaded) {"},
{"lineNum":"  257","line":"        return error.SkipZigTest;"},
{"lineNum":"  258","line":"    }"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"    const num_threads = 4;"},
{"lineNum":"  261","line":"    const num_increments = 1000;"},
{"lineNum":"  262","line":""},
{"lineNum":"  263","line":"    const Runner = struct {"},
{"lineNum":"  264","line":"        mutex: Mutex = .{},"},
{"lineNum":"  265","line":"        thread: Thread = undefined,"},
{"lineNum":"  266","line":"        counter: NonAtomicCounter = .{},"},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"        fn run(self: *@This()) void {"},
{"lineNum":"  269","line":"            var i: usize = num_increments;"},
{"lineNum":"  270","line":"            while (i > 0) : (i -= 1) {"},
{"lineNum":"  271","line":"                self.mutex.lock();"},
{"lineNum":"  272","line":"                defer self.mutex.unlock();"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"                self.counter.inc();"},
{"lineNum":"  275","line":"            }"},
{"lineNum":"  276","line":"        }"},
{"lineNum":"  277","line":"    };"},
{"lineNum":"  278","line":""},
{"lineNum":"  279","line":"    var runners = [_]Runner{.{}} ** num_threads;"},
{"lineNum":"  280","line":"    for (&runners) |*r| r.thread = try Thread.spawn(.{}, Runner.run, .{r});"},
{"lineNum":"  281","line":"    for (runners) |r| r.thread.join();"},
{"lineNum":"  282","line":"    for (runners) |r| try testing.expectEqual(r.counter.get(), num_increments);"},
{"lineNum":"  283","line":"}"},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"test \"Mutex - many contended\" {"},
{"lineNum":"  286","line":"    // This test requires spawning threads."},
{"lineNum":"  287","line":"    if (builtin.single_threaded) {"},
{"lineNum":"  288","line":"        return error.SkipZigTest;"},
{"lineNum":"  289","line":"    }"},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"    const num_threads = 4;"},
{"lineNum":"  292","line":"    const num_increments = 1000;"},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"    const Runner = struct {"},
{"lineNum":"  295","line":"        mutex: Mutex = .{},"},
{"lineNum":"  296","line":"        counter: NonAtomicCounter = .{},"},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"        fn run(self: *@This()) void {"},
{"lineNum":"  299","line":"            var i: usize = num_increments;"},
{"lineNum":"  300","line":"            while (i > 0) : (i -= 1) {"},
{"lineNum":"  301","line":"                // Occasionally hint to let another thread run."},
{"lineNum":"  302","line":"                defer if (i % 100 == 0) Thread.yield() catch {};"},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"                self.mutex.lock();"},
{"lineNum":"  305","line":"                defer self.mutex.unlock();"},
{"lineNum":"  306","line":""},
{"lineNum":"  307","line":"                self.counter.inc();"},
{"lineNum":"  308","line":"            }"},
{"lineNum":"  309","line":"        }"},
{"lineNum":"  310","line":"    };"},
{"lineNum":"  311","line":""},
{"lineNum":"  312","line":"    var runner = Runner{};"},
{"lineNum":"  313","line":""},
{"lineNum":"  314","line":"    var threads: [num_threads]Thread = undefined;"},
{"lineNum":"  315","line":"    for (&threads) |*t| t.* = try Thread.spawn(.{}, Runner.run, .{&runner});"},
{"lineNum":"  316","line":"    for (threads) |t| t.join();"},
{"lineNum":"  317","line":""},
{"lineNum":"  318","line":"    try testing.expectEqual(runner.counter.get(), num_increments * num_threads);"},
{"lineNum":"  319","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2023-04-18 20:41:50", "instrumented" : 35, "covered" : 27,};
var merged_data = [];
