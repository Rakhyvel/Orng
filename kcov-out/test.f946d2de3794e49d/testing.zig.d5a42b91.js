var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std.zig\");"},
{"lineNum":"    2","line":"const builtin = @import(\"builtin\");"},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"const math = std.math;"},
{"lineNum":"    5","line":"const print = std.debug.print;"},
{"lineNum":"    6","line":""},
{"lineNum":"    7","line":"pub const FailingAllocator = @import(\"testing/failing_allocator.zig\").FailingAllocator;"},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"/// This should only be used in temporary test programs."},
{"lineNum":"   10","line":"pub const allocator = allocator_instance.allocator();"},
{"lineNum":"   11","line":"pub var allocator_instance = b: {"},
{"lineNum":"   12","line":"    if (!builtin.is_test)"},
{"lineNum":"   13","line":"        @compileError(\"Cannot use testing allocator outside of test block\");"},
{"lineNum":"   14","line":"    break :b std.heap.GeneralPurposeAllocator(.{}){};"},
{"lineNum":"   15","line":"};"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"pub const failing_allocator = failing_allocator_instance.allocator();"},
{"lineNum":"   18","line":"pub var failing_allocator_instance = FailingAllocator.init(base_allocator_instance.allocator(), 0);"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"pub var base_allocator_instance = std.heap.FixedBufferAllocator.init(\"\");"},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"/// TODO https://github.com/ziglang/zig/issues/5738"},
{"lineNum":"   23","line":"pub var log_level = std.log.Level.warn;"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"/// This function is intended to be used only in tests. It prints diagnostics to stderr"},
{"lineNum":"   26","line":"/// and then returns a test failure error when actual_error_union is not expected_error."},
{"lineNum":"   27","line":"pub fn expectError(expected_error: anyerror, actual_error_union: anytype) !void {","class":"lineCov","hits":"1","order":"1991","possible_hits":"1",},
{"lineNum":"   28","line":"    if (actual_error_union) |actual_payload| {","class":"lineCov","hits":"1","order":"1992","possible_hits":"1",},
{"lineNum":"   29","line":"        std.debug.print(\"expected error.{s}, found {any}\\n\", .{ @errorName(expected_error), actual_payload });","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   30","line":"        return error.TestUnexpectedError;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   31","line":"    } else |actual_error| {"},
{"lineNum":"   32","line":"        if (expected_error != actual_error) {","class":"lineCov","hits":"1","order":"1993","possible_hits":"1",},
{"lineNum":"   33","line":"            std.debug.print(\"expected error.{s}, found error.{s}\\n\", .{"},
{"lineNum":"   34","line":"                @errorName(expected_error),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   35","line":"                @errorName(actual_error),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   36","line":"            });"},
{"lineNum":"   37","line":"            return error.TestExpectedError;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   38","line":"        }"},
{"lineNum":"   39","line":"    }"},
{"lineNum":"   40","line":"}"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"/// This function is intended to be used only in tests. When the two values are not"},
{"lineNum":"   43","line":"/// equal, prints diagnostics to stderr to show exactly how they are not equal,"},
{"lineNum":"   44","line":"/// then returns a test failure error."},
{"lineNum":"   45","line":"/// `actual` is casted to the type of `expected`."},
{"lineNum":"   46","line":"pub fn expectEqual(expected: anytype, actual: @TypeOf(expected)) !void {","class":"lineCov","hits":"3","order":"1757","possible_hits":"3",},
{"lineNum":"   47","line":"    switch (@typeInfo(@TypeOf(actual))) {"},
{"lineNum":"   48","line":"        .NoReturn,"},
{"lineNum":"   49","line":"        .Opaque,"},
{"lineNum":"   50","line":"        .Frame,"},
{"lineNum":"   51","line":"        .AnyFrame,"},
{"lineNum":"   52","line":"        => @compileError(\"value of type \" ++ @typeName(@TypeOf(actual)) ++ \" encountered\"),"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"        .Undefined,"},
{"lineNum":"   55","line":"        .Null,"},
{"lineNum":"   56","line":"        .Void,"},
{"lineNum":"   57","line":"        => return,"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"        .Type => {"},
{"lineNum":"   60","line":"            if (actual != expected) {"},
{"lineNum":"   61","line":"                std.debug.print(\"expected type {s}, found type {s}\\n\", .{ @typeName(expected), @typeName(actual) });"},
{"lineNum":"   62","line":"                return error.TestExpectedEqual;"},
{"lineNum":"   63","line":"            }"},
{"lineNum":"   64","line":"        },"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"        .Bool,"},
{"lineNum":"   67","line":"        .Int,"},
{"lineNum":"   68","line":"        .Float,"},
{"lineNum":"   69","line":"        .ComptimeFloat,"},
{"lineNum":"   70","line":"        .ComptimeInt,"},
{"lineNum":"   71","line":"        .EnumLiteral,"},
{"lineNum":"   72","line":"        .Enum,"},
{"lineNum":"   73","line":"        .Fn,"},
{"lineNum":"   74","line":"        .ErrorSet,"},
{"lineNum":"   75","line":"        => {"},
{"lineNum":"   76","line":"            if (actual != expected) {","class":"lineCov","hits":"3","order":"1758","possible_hits":"3",},
{"lineNum":"   77","line":"                std.debug.print(\"expected {}, found {}\\n\", .{ expected, actual });","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   78","line":"                return error.TestExpectedEqual;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   79","line":"            }"},
{"lineNum":"   80","line":"        },"},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"        .Pointer => |pointer| {"},
{"lineNum":"   83","line":"            switch (pointer.size) {"},
{"lineNum":"   84","line":"                .One, .Many, .C => {"},
{"lineNum":"   85","line":"                    if (actual != expected) {"},
{"lineNum":"   86","line":"                        std.debug.print(\"expected {*}, found {*}\\n\", .{ expected, actual });"},
{"lineNum":"   87","line":"                        return error.TestExpectedEqual;"},
{"lineNum":"   88","line":"                    }"},
{"lineNum":"   89","line":"                },"},
{"lineNum":"   90","line":"                .Slice => {"},
{"lineNum":"   91","line":"                    if (actual.ptr != expected.ptr) {"},
{"lineNum":"   92","line":"                        std.debug.print(\"expected slice ptr {*}, found {*}\\n\", .{ expected.ptr, actual.ptr });"},
{"lineNum":"   93","line":"                        return error.TestExpectedEqual;"},
{"lineNum":"   94","line":"                    }"},
{"lineNum":"   95","line":"                    if (actual.len != expected.len) {"},
{"lineNum":"   96","line":"                        std.debug.print(\"expected slice len {}, found {}\\n\", .{ expected.len, actual.len });"},
{"lineNum":"   97","line":"                        return error.TestExpectedEqual;"},
{"lineNum":"   98","line":"                    }"},
{"lineNum":"   99","line":"                },"},
{"lineNum":"  100","line":"            }"},
{"lineNum":"  101","line":"        },"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"        .Array => |array| try expectEqualSlices(array.child, &expected, &actual),"},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"        .Vector => |info| {"},
{"lineNum":"  106","line":"            var i: usize = 0;"},
{"lineNum":"  107","line":"            while (i < info.len) : (i += 1) {"},
{"lineNum":"  108","line":"                if (!std.meta.eql(expected[i], actual[i])) {"},
{"lineNum":"  109","line":"                    std.debug.print(\"index {} incorrect. expected {}, found {}\\n\", .{"},
{"lineNum":"  110","line":"                        i, expected[i], actual[i],"},
{"lineNum":"  111","line":"                    });"},
{"lineNum":"  112","line":"                    return error.TestExpectedEqual;"},
{"lineNum":"  113","line":"                }"},
{"lineNum":"  114","line":"            }"},
{"lineNum":"  115","line":"        },"},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"        .Struct => |structType| {"},
{"lineNum":"  118","line":"            inline for (structType.fields) |field| {"},
{"lineNum":"  119","line":"                try expectEqual(@field(expected, field.name), @field(actual, field.name));"},
{"lineNum":"  120","line":"            }"},
{"lineNum":"  121","line":"        },"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":"        .Union => |union_info| {"},
{"lineNum":"  124","line":"            if (union_info.tag_type == null) {"},
{"lineNum":"  125","line":"                @compileError(\"Unable to compare untagged union values\");"},
{"lineNum":"  126","line":"            }"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"            const Tag = std.meta.Tag(@TypeOf(expected));"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"            const expectedTag = @as(Tag, expected);"},
{"lineNum":"  131","line":"            const actualTag = @as(Tag, actual);"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"            try expectEqual(expectedTag, actualTag);"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"            // we only reach this loop if the tags are equal"},
{"lineNum":"  136","line":"            inline for (std.meta.fields(@TypeOf(actual))) |fld| {"},
{"lineNum":"  137","line":"                if (std.mem.eql(u8, fld.name, @tagName(actualTag))) {"},
{"lineNum":"  138","line":"                    try expectEqual(@field(expected, fld.name), @field(actual, fld.name));"},
{"lineNum":"  139","line":"                    return;"},
{"lineNum":"  140","line":"                }"},
{"lineNum":"  141","line":"            }"},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"            // we iterate over *all* union fields"},
{"lineNum":"  144","line":"            // => we should never get here as the loop above is"},
{"lineNum":"  145","line":"            //    including all possible values."},
{"lineNum":"  146","line":"            unreachable;"},
{"lineNum":"  147","line":"        },"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"        .Optional => {"},
{"lineNum":"  150","line":"            if (expected) |expected_payload| {"},
{"lineNum":"  151","line":"                if (actual) |actual_payload| {"},
{"lineNum":"  152","line":"                    try expectEqual(expected_payload, actual_payload);"},
{"lineNum":"  153","line":"                } else {"},
{"lineNum":"  154","line":"                    std.debug.print(\"expected {any}, found null\\n\", .{expected_payload});"},
{"lineNum":"  155","line":"                    return error.TestExpectedEqual;"},
{"lineNum":"  156","line":"                }"},
{"lineNum":"  157","line":"            } else {"},
{"lineNum":"  158","line":"                if (actual) |actual_payload| {"},
{"lineNum":"  159","line":"                    std.debug.print(\"expected null, found {any}\\n\", .{actual_payload});"},
{"lineNum":"  160","line":"                    return error.TestExpectedEqual;"},
{"lineNum":"  161","line":"                }"},
{"lineNum":"  162","line":"            }"},
{"lineNum":"  163","line":"        },"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"        .ErrorUnion => {"},
{"lineNum":"  166","line":"            if (expected) |expected_payload| {"},
{"lineNum":"  167","line":"                if (actual) |actual_payload| {"},
{"lineNum":"  168","line":"                    try expectEqual(expected_payload, actual_payload);"},
{"lineNum":"  169","line":"                } else |actual_err| {"},
{"lineNum":"  170","line":"                    std.debug.print(\"expected {any}, found {}\\n\", .{ expected_payload, actual_err });"},
{"lineNum":"  171","line":"                    return error.TestExpectedEqual;"},
{"lineNum":"  172","line":"                }"},
{"lineNum":"  173","line":"            } else |expected_err| {"},
{"lineNum":"  174","line":"                if (actual) |actual_payload| {"},
{"lineNum":"  175","line":"                    std.debug.print(\"expected {}, found {any}\\n\", .{ expected_err, actual_payload });"},
{"lineNum":"  176","line":"                    return error.TestExpectedEqual;"},
{"lineNum":"  177","line":"                } else |actual_err| {"},
{"lineNum":"  178","line":"                    try expectEqual(expected_err, actual_err);"},
{"lineNum":"  179","line":"                }"},
{"lineNum":"  180","line":"            }"},
{"lineNum":"  181","line":"        },"},
{"lineNum":"  182","line":"    }"},
{"lineNum":"  183","line":"}"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"test \"expectEqual.union(enum)\" {"},
{"lineNum":"  186","line":"    const T = union(enum) {"},
{"lineNum":"  187","line":"        a: i32,"},
{"lineNum":"  188","line":"        b: f32,"},
{"lineNum":"  189","line":"    };"},
{"lineNum":"  190","line":""},
{"lineNum":"  191","line":"    const a10 = T{ .a = 10 };"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"    try expectEqual(a10, a10);"},
{"lineNum":"  194","line":"}"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"/// This function is intended to be used only in tests. When the formatted result of the template"},
{"lineNum":"  197","line":"/// and its arguments does not equal the expected text, it prints diagnostics to stderr to show how"},
{"lineNum":"  198","line":"/// they are not equal, then returns an error."},
{"lineNum":"  199","line":"pub fn expectFmt(expected: []const u8, comptime template: []const u8, args: anytype) !void {"},
{"lineNum":"  200","line":"    const result = try std.fmt.allocPrint(allocator, template, args);"},
{"lineNum":"  201","line":"    defer allocator.free(result);"},
{"lineNum":"  202","line":"    if (std.mem.eql(u8, result, expected)) return;"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"    print(\"\\n====== expected this output: =========\\n\", .{});"},
{"lineNum":"  205","line":"    print(\"{s}\", .{expected});"},
{"lineNum":"  206","line":"    print(\"\\n======== instead found this: =========\\n\", .{});"},
{"lineNum":"  207","line":"    print(\"{s}\", .{result});"},
{"lineNum":"  208","line":"    print(\"\\n======================================\\n\", .{});"},
{"lineNum":"  209","line":"    return error.TestExpectedFmt;"},
{"lineNum":"  210","line":"}"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"/// This function is intended to be used only in tests. When the actual value is"},
{"lineNum":"  213","line":"/// not approximately equal to the expected value, prints diagnostics to stderr"},
{"lineNum":"  214","line":"/// to show exactly how they are not equal, then returns a test failure error."},
{"lineNum":"  215","line":"/// See `math.approxEqAbs` for more information on the tolerance parameter."},
{"lineNum":"  216","line":"/// The types must be floating-point."},
{"lineNum":"  217","line":"pub fn expectApproxEqAbs(expected: anytype, actual: @TypeOf(expected), tolerance: @TypeOf(expected)) !void {"},
{"lineNum":"  218","line":"    const T = @TypeOf(expected);"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"    switch (@typeInfo(T)) {"},
{"lineNum":"  221","line":"        .Float => if (!math.approxEqAbs(T, expected, actual, tolerance)) {"},
{"lineNum":"  222","line":"            std.debug.print(\"actual {}, not within absolute tolerance {} of expected {}\\n\", .{ actual, tolerance, expected });"},
{"lineNum":"  223","line":"            return error.TestExpectedApproxEqAbs;"},
{"lineNum":"  224","line":"        },"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"        .ComptimeFloat => @compileError(\"Cannot approximately compare two comptime_float values\"),"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"        else => @compileError(\"Unable to compare non floating point values\"),"},
{"lineNum":"  229","line":"    }"},
{"lineNum":"  230","line":"}"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"test \"expectApproxEqAbs\" {"},
{"lineNum":"  233","line":"    inline for ([_]type{ f16, f32, f64, f128 }) |T| {"},
{"lineNum":"  234","line":"        const pos_x: T = 12.0;"},
{"lineNum":"  235","line":"        const pos_y: T = 12.06;"},
{"lineNum":"  236","line":"        const neg_x: T = -12.0;"},
{"lineNum":"  237","line":"        const neg_y: T = -12.06;"},
{"lineNum":"  238","line":""},
{"lineNum":"  239","line":"        try expectApproxEqAbs(pos_x, pos_y, 0.1);"},
{"lineNum":"  240","line":"        try expectApproxEqAbs(neg_x, neg_y, 0.1);"},
{"lineNum":"  241","line":"    }"},
{"lineNum":"  242","line":"}"},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"/// This function is intended to be used only in tests. When the actual value is"},
{"lineNum":"  245","line":"/// not approximately equal to the expected value, prints diagnostics to stderr"},
{"lineNum":"  246","line":"/// to show exactly how they are not equal, then returns a test failure error."},
{"lineNum":"  247","line":"/// See `math.approxEqRel` for more information on the tolerance parameter."},
{"lineNum":"  248","line":"/// The types must be floating-point."},
{"lineNum":"  249","line":"pub fn expectApproxEqRel(expected: anytype, actual: @TypeOf(expected), tolerance: @TypeOf(expected)) !void {"},
{"lineNum":"  250","line":"    const T = @TypeOf(expected);"},
{"lineNum":"  251","line":""},
{"lineNum":"  252","line":"    switch (@typeInfo(T)) {"},
{"lineNum":"  253","line":"        .Float => if (!math.approxEqRel(T, expected, actual, tolerance)) {"},
{"lineNum":"  254","line":"            std.debug.print(\"actual {}, not within relative tolerance {} of expected {}\\n\", .{ actual, tolerance, expected });"},
{"lineNum":"  255","line":"            return error.TestExpectedApproxEqRel;"},
{"lineNum":"  256","line":"        },"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"        .ComptimeFloat => @compileError(\"Cannot approximately compare two comptime_float values\"),"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"        else => @compileError(\"Unable to compare non floating point values\"),"},
{"lineNum":"  261","line":"    }"},
{"lineNum":"  262","line":"}"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"test \"expectApproxEqRel\" {"},
{"lineNum":"  265","line":"    inline for ([_]type{ f16, f32, f64, f128 }) |T| {"},
{"lineNum":"  266","line":"        const eps_value = comptime math.epsilon(T);"},
{"lineNum":"  267","line":"        const sqrt_eps_value = comptime @sqrt(eps_value);"},
{"lineNum":"  268","line":""},
{"lineNum":"  269","line":"        const pos_x: T = 12.0;"},
{"lineNum":"  270","line":"        const pos_y: T = pos_x + 2 * eps_value;"},
{"lineNum":"  271","line":"        const neg_x: T = -12.0;"},
{"lineNum":"  272","line":"        const neg_y: T = neg_x - 2 * eps_value;"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"        try expectApproxEqRel(pos_x, pos_y, sqrt_eps_value);"},
{"lineNum":"  275","line":"        try expectApproxEqRel(neg_x, neg_y, sqrt_eps_value);"},
{"lineNum":"  276","line":"    }"},
{"lineNum":"  277","line":"}"},
{"lineNum":"  278","line":""},
{"lineNum":"  279","line":"/// This function is intended to be used only in tests. When the two slices are not"},
{"lineNum":"  280","line":"/// equal, prints diagnostics to stderr to show exactly how they are not equal (with"},
{"lineNum":"  281","line":"/// the differences highlighted in red), then returns a test failure error."},
{"lineNum":"  282","line":"/// The colorized output is optional and controlled by the return of `std.debug.detectTTYConfig()`."},
{"lineNum":"  283","line":"/// If your inputs are UTF-8 encoded strings, consider calling `expectEqualStrings` instead."},
{"lineNum":"  284","line":"pub fn expectEqualSlices(comptime T: type, expected: []const T, actual: []const T) !void {"},
{"lineNum":"  285","line":"    if (expected.ptr == actual.ptr and expected.len == actual.len) {"},
{"lineNum":"  286","line":"        return;"},
{"lineNum":"  287","line":"    }"},
{"lineNum":"  288","line":"    const diff_index: usize = diff_index: {"},
{"lineNum":"  289","line":"        const shortest = @min(expected.len, actual.len);"},
{"lineNum":"  290","line":"        var index: usize = 0;"},
{"lineNum":"  291","line":"        while (index < shortest) : (index += 1) {"},
{"lineNum":"  292","line":"            if (!std.meta.eql(actual[index], expected[index])) break :diff_index index;"},
{"lineNum":"  293","line":"        }"},
{"lineNum":"  294","line":"        break :diff_index if (expected.len == actual.len) return else shortest;"},
{"lineNum":"  295","line":"    };"},
{"lineNum":"  296","line":""},
{"lineNum":"  297","line":"    std.debug.print(\"slices differ. first difference occurs at index {d} (0x{X})\\n\", .{ diff_index, diff_index });"},
{"lineNum":"  298","line":""},
{"lineNum":"  299","line":"    // TODO: Should this be configurable by the caller?"},
{"lineNum":"  300","line":"    const max_lines: usize = 16;"},
{"lineNum":"  301","line":"    const max_window_size: usize = if (T == u8) max_lines * 16 else max_lines;"},
{"lineNum":"  302","line":""},
{"lineNum":"  303","line":"    // Print a maximum of max_window_size items of each input, starting just before the"},
{"lineNum":"  304","line":"    // first difference to give a bit of context."},
{"lineNum":"  305","line":"    var window_start: usize = 0;"},
{"lineNum":"  306","line":"    if (@max(actual.len, expected.len) > max_window_size) {"},
{"lineNum":"  307","line":"        const alignment = if (T == u8) 16 else 2;"},
{"lineNum":"  308","line":"        window_start = std.mem.alignBackward(diff_index - @min(diff_index, alignment), alignment);"},
{"lineNum":"  309","line":"    }"},
{"lineNum":"  310","line":"    const expected_window = expected[window_start..@min(expected.len, window_start + max_window_size)];"},
{"lineNum":"  311","line":"    const expected_truncated = window_start + expected_window.len < expected.len;"},
{"lineNum":"  312","line":"    const actual_window = actual[window_start..@min(actual.len, window_start + max_window_size)];"},
{"lineNum":"  313","line":"    const actual_truncated = window_start + actual_window.len < actual.len;"},
{"lineNum":"  314","line":""},
{"lineNum":"  315","line":"    const ttyconf = std.debug.detectTTYConfig(std.io.getStdErr());"},
{"lineNum":"  316","line":"    var differ = if (T == u8) BytesDiffer{"},
{"lineNum":"  317","line":"        .expected = expected_window,"},
{"lineNum":"  318","line":"        .actual = actual_window,"},
{"lineNum":"  319","line":"        .ttyconf = ttyconf,"},
{"lineNum":"  320","line":"    } else SliceDiffer(T){"},
{"lineNum":"  321","line":"        .start_index = window_start,"},
{"lineNum":"  322","line":"        .expected = expected_window,"},
{"lineNum":"  323","line":"        .actual = actual_window,"},
{"lineNum":"  324","line":"        .ttyconf = ttyconf,"},
{"lineNum":"  325","line":"    };"},
{"lineNum":"  326","line":"    const stderr = std.io.getStdErr();"},
{"lineNum":"  327","line":""},
{"lineNum":"  328","line":"    // Print indexes as hex for slices of u8 since it\'s more likely to be binary data where"},
{"lineNum":"  329","line":"    // that is usually useful."},
{"lineNum":"  330","line":"    const index_fmt = if (T == u8) \"0x{X}\" else \"{}\";"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"    std.debug.print(\"\\n============ expected this output: =============  len: {} (0x{X})\\n\\n\", .{ expected.len, expected.len });"},
{"lineNum":"  333","line":"    if (window_start > 0) {"},
{"lineNum":"  334","line":"        if (T == u8) {"},
{"lineNum":"  335","line":"            std.debug.print(\"... truncated, start index: \" ++ index_fmt ++ \" ...\\n\", .{window_start});"},
{"lineNum":"  336","line":"        } else {"},
{"lineNum":"  337","line":"            std.debug.print(\"... truncated ...\\n\", .{});"},
{"lineNum":"  338","line":"        }"},
{"lineNum":"  339","line":"    }"},
{"lineNum":"  340","line":"    differ.write(stderr.writer()) catch {};"},
{"lineNum":"  341","line":"    if (expected_truncated) {"},
{"lineNum":"  342","line":"        const end_offset = window_start + expected_window.len;"},
{"lineNum":"  343","line":"        const num_missing_items = expected.len - (window_start + expected_window.len);"},
{"lineNum":"  344","line":"        if (T == u8) {"},
{"lineNum":"  345","line":"            std.debug.print(\"... truncated, indexes [\" ++ index_fmt ++ \"..] not shown, remaining bytes: \" ++ index_fmt ++ \" ...\\n\", .{ end_offset, num_missing_items });"},
{"lineNum":"  346","line":"        } else {"},
{"lineNum":"  347","line":"            std.debug.print(\"... truncated, remaining items: \" ++ index_fmt ++ \" ...\\n\", .{num_missing_items});"},
{"lineNum":"  348","line":"        }"},
{"lineNum":"  349","line":"    }"},
{"lineNum":"  350","line":""},
{"lineNum":"  351","line":"    // now reverse expected/actual and print again"},
{"lineNum":"  352","line":"    differ.expected = actual_window;"},
{"lineNum":"  353","line":"    differ.actual = expected_window;"},
{"lineNum":"  354","line":"    std.debug.print(\"\\n============= instead found this: ==============  len: {} (0x{X})\\n\\n\", .{ actual.len, actual.len });"},
{"lineNum":"  355","line":"    if (window_start > 0) {"},
{"lineNum":"  356","line":"        if (T == u8) {"},
{"lineNum":"  357","line":"            std.debug.print(\"... truncated, start index: \" ++ index_fmt ++ \" ...\\n\", .{window_start});"},
{"lineNum":"  358","line":"        } else {"},
{"lineNum":"  359","line":"            std.debug.print(\"... truncated ...\\n\", .{});"},
{"lineNum":"  360","line":"        }"},
{"lineNum":"  361","line":"    }"},
{"lineNum":"  362","line":"    differ.write(stderr.writer()) catch {};"},
{"lineNum":"  363","line":"    if (actual_truncated) {"},
{"lineNum":"  364","line":"        const end_offset = window_start + actual_window.len;"},
{"lineNum":"  365","line":"        const num_missing_items = actual.len - (window_start + actual_window.len);"},
{"lineNum":"  366","line":"        if (T == u8) {"},
{"lineNum":"  367","line":"            std.debug.print(\"... truncated, indexes [\" ++ index_fmt ++ \"..] not shown, remaining bytes: \" ++ index_fmt ++ \" ...\\n\", .{ end_offset, num_missing_items });"},
{"lineNum":"  368","line":"        } else {"},
{"lineNum":"  369","line":"            std.debug.print(\"... truncated, remaining items: \" ++ index_fmt ++ \" ...\\n\", .{num_missing_items});"},
{"lineNum":"  370","line":"        }"},
{"lineNum":"  371","line":"    }"},
{"lineNum":"  372","line":"    std.debug.print(\"\\n================================================\\n\\n\", .{});"},
{"lineNum":"  373","line":""},
{"lineNum":"  374","line":"    return error.TestExpectedEqual;"},
{"lineNum":"  375","line":"}"},
{"lineNum":"  376","line":""},
{"lineNum":"  377","line":"fn SliceDiffer(comptime T: type) type {"},
{"lineNum":"  378","line":"    return struct {"},
{"lineNum":"  379","line":"        start_index: usize,"},
{"lineNum":"  380","line":"        expected: []const T,"},
{"lineNum":"  381","line":"        actual: []const T,"},
{"lineNum":"  382","line":"        ttyconf: std.debug.TTY.Config,"},
{"lineNum":"  383","line":""},
{"lineNum":"  384","line":"        const Self = @This();"},
{"lineNum":"  385","line":""},
{"lineNum":"  386","line":"        pub fn write(self: Self, writer: anytype) !void {"},
{"lineNum":"  387","line":"            for (self.expected, 0..) |value, i| {"},
{"lineNum":"  388","line":"                var full_index = self.start_index + i;"},
{"lineNum":"  389","line":"                const diff = if (i < self.actual.len) !std.meta.eql(self.actual[i], value) else true;"},
{"lineNum":"  390","line":"                if (diff) try self.ttyconf.setColor(writer, .Red);"},
{"lineNum":"  391","line":"                try writer.print(\"[{}]: {any}\\n\", .{ full_index, value });"},
{"lineNum":"  392","line":"                if (diff) try self.ttyconf.setColor(writer, .Reset);"},
{"lineNum":"  393","line":"            }"},
{"lineNum":"  394","line":"        }"},
{"lineNum":"  395","line":"    };"},
{"lineNum":"  396","line":"}"},
{"lineNum":"  397","line":""},
{"lineNum":"  398","line":"const BytesDiffer = struct {"},
{"lineNum":"  399","line":"    expected: []const u8,"},
{"lineNum":"  400","line":"    actual: []const u8,"},
{"lineNum":"  401","line":"    ttyconf: std.debug.TTY.Config,"},
{"lineNum":"  402","line":""},
{"lineNum":"  403","line":"    pub fn write(self: BytesDiffer, writer: anytype) !void {"},
{"lineNum":"  404","line":"        var expected_iterator = ChunkIterator{ .bytes = self.expected };"},
{"lineNum":"  405","line":"        while (expected_iterator.next()) |chunk| {"},
{"lineNum":"  406","line":"            // to avoid having to calculate diffs twice per chunk"},
{"lineNum":"  407","line":"            var diffs: std.bit_set.IntegerBitSet(16) = .{ .mask = 0 };"},
{"lineNum":"  408","line":"            for (chunk, 0..) |byte, i| {"},
{"lineNum":"  409","line":"                var absolute_byte_index = (expected_iterator.index - chunk.len) + i;"},
{"lineNum":"  410","line":"                const diff = if (absolute_byte_index < self.actual.len) self.actual[absolute_byte_index] != byte else true;"},
{"lineNum":"  411","line":"                if (diff) diffs.set(i);"},
{"lineNum":"  412","line":"                try self.writeByteDiff(writer, \"{X:0>2} \", byte, diff);"},
{"lineNum":"  413","line":"                if (i == 7) try writer.writeByte(\' \');"},
{"lineNum":"  414","line":"            }"},
{"lineNum":"  415","line":"            try writer.writeByte(\' \');"},
{"lineNum":"  416","line":"            if (chunk.len < 16) {"},
{"lineNum":"  417","line":"                var missing_columns = (16 - chunk.len) * 3;"},
{"lineNum":"  418","line":"                if (chunk.len < 8) missing_columns += 1;"},
{"lineNum":"  419","line":"                try writer.writeByteNTimes(\' \', missing_columns);"},
{"lineNum":"  420","line":"            }"},
{"lineNum":"  421","line":"            for (chunk, 0..) |byte, i| {"},
{"lineNum":"  422","line":"                const byte_to_print = if (std.ascii.isPrint(byte)) byte else \'.\';"},
{"lineNum":"  423","line":"                try self.writeByteDiff(writer, \"{c}\", byte_to_print, diffs.isSet(i));"},
{"lineNum":"  424","line":"            }"},
{"lineNum":"  425","line":"            try writer.writeByte(\'\\n\');"},
{"lineNum":"  426","line":"        }"},
{"lineNum":"  427","line":"    }"},
{"lineNum":"  428","line":""},
{"lineNum":"  429","line":"    fn writeByteDiff(self: BytesDiffer, writer: anytype, comptime fmt: []const u8, byte: u8, diff: bool) !void {"},
{"lineNum":"  430","line":"        if (diff) try self.ttyconf.setColor(writer, .Red);"},
{"lineNum":"  431","line":"        try writer.print(fmt, .{byte});"},
{"lineNum":"  432","line":"        if (diff) try self.ttyconf.setColor(writer, .Reset);"},
{"lineNum":"  433","line":"    }"},
{"lineNum":"  434","line":""},
{"lineNum":"  435","line":"    const ChunkIterator = struct {"},
{"lineNum":"  436","line":"        bytes: []const u8,"},
{"lineNum":"  437","line":"        index: usize = 0,"},
{"lineNum":"  438","line":""},
{"lineNum":"  439","line":"        pub fn next(self: *ChunkIterator) ?[]const u8 {"},
{"lineNum":"  440","line":"            if (self.index == self.bytes.len) return null;"},
{"lineNum":"  441","line":""},
{"lineNum":"  442","line":"            const start_index = self.index;"},
{"lineNum":"  443","line":"            const end_index = @min(self.bytes.len, start_index + 16);"},
{"lineNum":"  444","line":"            self.index = end_index;"},
{"lineNum":"  445","line":"            return self.bytes[start_index..end_index];"},
{"lineNum":"  446","line":"        }"},
{"lineNum":"  447","line":"    };"},
{"lineNum":"  448","line":"};"},
{"lineNum":"  449","line":""},
{"lineNum":"  450","line":"test {"},
{"lineNum":"  451","line":"    try expectEqualSlices(u8, \"foo\\x00\", \"foo\\x00\");"},
{"lineNum":"  452","line":"    try expectEqualSlices(u16, &[_]u16{ 100, 200, 300, 400 }, &[_]u16{ 100, 200, 300, 400 });"},
{"lineNum":"  453","line":"    const E = enum { foo, bar };"},
{"lineNum":"  454","line":"    const S = struct {"},
{"lineNum":"  455","line":"        v: E,"},
{"lineNum":"  456","line":"    };"},
{"lineNum":"  457","line":"    try expectEqualSlices("},
{"lineNum":"  458","line":"        S,"},
{"lineNum":"  459","line":"        &[_]S{ .{ .v = .foo }, .{ .v = .bar }, .{ .v = .foo }, .{ .v = .bar } },"},
{"lineNum":"  460","line":"        &[_]S{ .{ .v = .foo }, .{ .v = .bar }, .{ .v = .foo }, .{ .v = .bar } },"},
{"lineNum":"  461","line":"    );"},
{"lineNum":"  462","line":"}"},
{"lineNum":"  463","line":""},
{"lineNum":"  464","line":"/// This function is intended to be used only in tests. Checks that two slices or two arrays are equal,"},
{"lineNum":"  465","line":"/// including that their sentinel (if any) are the same. Will error if given another type."},
{"lineNum":"  466","line":"pub fn expectEqualSentinel(comptime T: type, comptime sentinel: T, expected: [:sentinel]const T, actual: [:sentinel]const T) !void {"},
{"lineNum":"  467","line":"    try expectEqualSlices(T, expected, actual);"},
{"lineNum":"  468","line":""},
{"lineNum":"  469","line":"    const expected_value_sentinel = blk: {"},
{"lineNum":"  470","line":"        switch (@typeInfo(@TypeOf(expected))) {"},
{"lineNum":"  471","line":"            .Pointer => {"},
{"lineNum":"  472","line":"                break :blk expected[expected.len];"},
{"lineNum":"  473","line":"            },"},
{"lineNum":"  474","line":"            .Array => |array_info| {"},
{"lineNum":"  475","line":"                const indexable_outside_of_bounds = @as([]const array_info.child, &expected);"},
{"lineNum":"  476","line":"                break :blk indexable_outside_of_bounds[indexable_outside_of_bounds.len];"},
{"lineNum":"  477","line":"            },"},
{"lineNum":"  478","line":"            else => {},"},
{"lineNum":"  479","line":"        }"},
{"lineNum":"  480","line":"    };"},
{"lineNum":"  481","line":""},
{"lineNum":"  482","line":"    const actual_value_sentinel = blk: {"},
{"lineNum":"  483","line":"        switch (@typeInfo(@TypeOf(actual))) {"},
{"lineNum":"  484","line":"            .Pointer => {"},
{"lineNum":"  485","line":"                break :blk actual[actual.len];"},
{"lineNum":"  486","line":"            },"},
{"lineNum":"  487","line":"            .Array => |array_info| {"},
{"lineNum":"  488","line":"                const indexable_outside_of_bounds = @as([]const array_info.child, &actual);"},
{"lineNum":"  489","line":"                break :blk indexable_outside_of_bounds[indexable_outside_of_bounds.len];"},
{"lineNum":"  490","line":"            },"},
{"lineNum":"  491","line":"            else => {},"},
{"lineNum":"  492","line":"        }"},
{"lineNum":"  493","line":"    };"},
{"lineNum":"  494","line":""},
{"lineNum":"  495","line":"    if (!std.meta.eql(sentinel, expected_value_sentinel)) {"},
{"lineNum":"  496","line":"        std.debug.print(\"expectEqualSentinel: \'expected\' sentinel in memory is different from its type sentinel. type sentinel {}, in memory sentinel {}\\n\", .{ sentinel, expected_value_sentinel });"},
{"lineNum":"  497","line":"        return error.TestExpectedEqual;"},
{"lineNum":"  498","line":"    }"},
{"lineNum":"  499","line":""},
{"lineNum":"  500","line":"    if (!std.meta.eql(sentinel, actual_value_sentinel)) {"},
{"lineNum":"  501","line":"        std.debug.print(\"expectEqualSentinel: \'actual\' sentinel in memory is different from its type sentinel. type sentinel {}, in memory sentinel {}\\n\", .{ sentinel, actual_value_sentinel });"},
{"lineNum":"  502","line":"        return error.TestExpectedEqual;"},
{"lineNum":"  503","line":"    }"},
{"lineNum":"  504","line":"}"},
{"lineNum":"  505","line":""},
{"lineNum":"  506","line":"/// This function is intended to be used only in tests."},
{"lineNum":"  507","line":"/// When `ok` is false, returns a test failure error."},
{"lineNum":"  508","line":"pub fn expect(ok: bool) !void {"},
{"lineNum":"  509","line":"    if (!ok) return error.TestUnexpectedResult;"},
{"lineNum":"  510","line":"}"},
{"lineNum":"  511","line":""},
{"lineNum":"  512","line":"pub const TmpDir = struct {"},
{"lineNum":"  513","line":"    dir: std.fs.Dir,"},
{"lineNum":"  514","line":"    parent_dir: std.fs.Dir,"},
{"lineNum":"  515","line":"    sub_path: [sub_path_len]u8,"},
{"lineNum":"  516","line":""},
{"lineNum":"  517","line":"    const random_bytes_count = 12;"},
{"lineNum":"  518","line":"    const sub_path_len = std.fs.base64_encoder.calcSize(random_bytes_count);"},
{"lineNum":"  519","line":""},
{"lineNum":"  520","line":"    pub fn cleanup(self: *TmpDir) void {"},
{"lineNum":"  521","line":"        self.dir.close();"},
{"lineNum":"  522","line":"        self.parent_dir.deleteTree(&self.sub_path) catch {};"},
{"lineNum":"  523","line":"        self.parent_dir.close();"},
{"lineNum":"  524","line":"        self.* = undefined;"},
{"lineNum":"  525","line":"    }"},
{"lineNum":"  526","line":"};"},
{"lineNum":"  527","line":""},
{"lineNum":"  528","line":"pub const TmpIterableDir = struct {"},
{"lineNum":"  529","line":"    iterable_dir: std.fs.IterableDir,"},
{"lineNum":"  530","line":"    parent_dir: std.fs.Dir,"},
{"lineNum":"  531","line":"    sub_path: [sub_path_len]u8,"},
{"lineNum":"  532","line":""},
{"lineNum":"  533","line":"    const random_bytes_count = 12;"},
{"lineNum":"  534","line":"    const sub_path_len = std.fs.base64_encoder.calcSize(random_bytes_count);"},
{"lineNum":"  535","line":""},
{"lineNum":"  536","line":"    pub fn cleanup(self: *TmpIterableDir) void {"},
{"lineNum":"  537","line":"        self.iterable_dir.close();"},
{"lineNum":"  538","line":"        self.parent_dir.deleteTree(&self.sub_path) catch {};"},
{"lineNum":"  539","line":"        self.parent_dir.close();"},
{"lineNum":"  540","line":"        self.* = undefined;"},
{"lineNum":"  541","line":"    }"},
{"lineNum":"  542","line":"};"},
{"lineNum":"  543","line":""},
{"lineNum":"  544","line":"pub fn tmpDir(opts: std.fs.Dir.OpenDirOptions) TmpDir {"},
{"lineNum":"  545","line":"    var random_bytes: [TmpDir.random_bytes_count]u8 = undefined;"},
{"lineNum":"  546","line":"    std.crypto.random.bytes(&random_bytes);"},
{"lineNum":"  547","line":"    var sub_path: [TmpDir.sub_path_len]u8 = undefined;"},
{"lineNum":"  548","line":"    _ = std.fs.base64_encoder.encode(&sub_path, &random_bytes);"},
{"lineNum":"  549","line":""},
{"lineNum":"  550","line":"    var cwd = std.fs.cwd();"},
{"lineNum":"  551","line":"    var cache_dir = cwd.makeOpenPath(\"zig-cache\", .{}) catch"},
{"lineNum":"  552","line":"        @panic(\"unable to make tmp dir for testing: unable to make and open zig-cache dir\");"},
{"lineNum":"  553","line":"    defer cache_dir.close();"},
{"lineNum":"  554","line":"    var parent_dir = cache_dir.makeOpenPath(\"tmp\", .{}) catch"},
{"lineNum":"  555","line":"        @panic(\"unable to make tmp dir for testing: unable to make and open zig-cache/tmp dir\");"},
{"lineNum":"  556","line":"    var dir = parent_dir.makeOpenPath(&sub_path, opts) catch"},
{"lineNum":"  557","line":"        @panic(\"unable to make tmp dir for testing: unable to make and open the tmp dir\");"},
{"lineNum":"  558","line":""},
{"lineNum":"  559","line":"    return .{"},
{"lineNum":"  560","line":"        .dir = dir,"},
{"lineNum":"  561","line":"        .parent_dir = parent_dir,"},
{"lineNum":"  562","line":"        .sub_path = sub_path,"},
{"lineNum":"  563","line":"    };"},
{"lineNum":"  564","line":"}"},
{"lineNum":"  565","line":""},
{"lineNum":"  566","line":"pub fn tmpIterableDir(opts: std.fs.Dir.OpenDirOptions) TmpIterableDir {"},
{"lineNum":"  567","line":"    var random_bytes: [TmpIterableDir.random_bytes_count]u8 = undefined;"},
{"lineNum":"  568","line":"    std.crypto.random.bytes(&random_bytes);"},
{"lineNum":"  569","line":"    var sub_path: [TmpIterableDir.sub_path_len]u8 = undefined;"},
{"lineNum":"  570","line":"    _ = std.fs.base64_encoder.encode(&sub_path, &random_bytes);"},
{"lineNum":"  571","line":""},
{"lineNum":"  572","line":"    var cwd = std.fs.cwd();"},
{"lineNum":"  573","line":"    var cache_dir = cwd.makeOpenPath(\"zig-cache\", .{}) catch"},
{"lineNum":"  574","line":"        @panic(\"unable to make tmp dir for testing: unable to make and open zig-cache dir\");"},
{"lineNum":"  575","line":"    defer cache_dir.close();"},
{"lineNum":"  576","line":"    var parent_dir = cache_dir.makeOpenPath(\"tmp\", .{}) catch"},
{"lineNum":"  577","line":"        @panic(\"unable to make tmp dir for testing: unable to make and open zig-cache/tmp dir\");"},
{"lineNum":"  578","line":"    var dir = parent_dir.makeOpenPathIterable(&sub_path, opts) catch"},
{"lineNum":"  579","line":"        @panic(\"unable to make tmp dir for testing: unable to make and open the tmp dir\");"},
{"lineNum":"  580","line":""},
{"lineNum":"  581","line":"    return .{"},
{"lineNum":"  582","line":"        .iterable_dir = dir,"},
{"lineNum":"  583","line":"        .parent_dir = parent_dir,"},
{"lineNum":"  584","line":"        .sub_path = sub_path,"},
{"lineNum":"  585","line":"    };"},
{"lineNum":"  586","line":"}"},
{"lineNum":"  587","line":""},
{"lineNum":"  588","line":"test \"expectEqual nested array\" {"},
{"lineNum":"  589","line":"    const a = [2][2]f32{"},
{"lineNum":"  590","line":"        [_]f32{ 1.0, 0.0 },"},
{"lineNum":"  591","line":"        [_]f32{ 0.0, 1.0 },"},
{"lineNum":"  592","line":"    };"},
{"lineNum":"  593","line":""},
{"lineNum":"  594","line":"    const b = [2][2]f32{"},
{"lineNum":"  595","line":"        [_]f32{ 1.0, 0.0 },"},
{"lineNum":"  596","line":"        [_]f32{ 0.0, 1.0 },"},
{"lineNum":"  597","line":"    };"},
{"lineNum":"  598","line":""},
{"lineNum":"  599","line":"    try expectEqual(a, b);"},
{"lineNum":"  600","line":"}"},
{"lineNum":"  601","line":""},
{"lineNum":"  602","line":"test \"expectEqual vector\" {"},
{"lineNum":"  603","line":"    var a = @splat(4, @as(u32, 4));"},
{"lineNum":"  604","line":"    var b = @splat(4, @as(u32, 4));"},
{"lineNum":"  605","line":""},
{"lineNum":"  606","line":"    try expectEqual(a, b);"},
{"lineNum":"  607","line":"}"},
{"lineNum":"  608","line":""},
{"lineNum":"  609","line":"pub fn expectEqualStrings(expected: []const u8, actual: []const u8) !void {","class":"lineCov","hits":"1","order":"1579","possible_hits":"1",},
{"lineNum":"  610","line":"    if (std.mem.indexOfDiff(u8, actual, expected)) |diff_index| {","class":"lineCov","hits":"1","order":"1580","possible_hits":"1",},
{"lineNum":"  611","line":"        print(\"\\n====== expected this output: =========\\n\", .{});","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  612","line":"        printWithVisibleNewlines(expected);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  613","line":"        print(\"\\n======== instead found this: =========\\n\", .{});","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  614","line":"        printWithVisibleNewlines(actual);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  615","line":"        print(\"\\n======================================\\n\", .{});","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  616","line":""},
{"lineNum":"  617","line":"        var diff_line_number: usize = 1;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  618","line":"        for (expected[0..diff_index]) |value| {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  619","line":"            if (value == \'\\n\') diff_line_number += 1;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  620","line":"        }"},
{"lineNum":"  621","line":"        print(\"First difference occurs on line {d}:\\n\", .{diff_line_number});","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  622","line":""},
{"lineNum":"  623","line":"        print(\"expected:\\n\", .{});","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  624","line":"        printIndicatorLine(expected, diff_index);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  625","line":""},
{"lineNum":"  626","line":"        print(\"found:\\n\", .{});","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  627","line":"        printIndicatorLine(actual, diff_index);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  628","line":""},
{"lineNum":"  629","line":"        return error.TestExpectedEqual;","class":"linePartCov","hits":"1","order":"1590","possible_hits":"2",},
{"lineNum":"  630","line":"    }"},
{"lineNum":"  631","line":"}"},
{"lineNum":"  632","line":""},
{"lineNum":"  633","line":"pub fn expectStringStartsWith(actual: []const u8, expected_starts_with: []const u8) !void {"},
{"lineNum":"  634","line":"    if (std.mem.startsWith(u8, actual, expected_starts_with))"},
{"lineNum":"  635","line":"        return;"},
{"lineNum":"  636","line":""},
{"lineNum":"  637","line":"    const shortened_actual = if (actual.len >= expected_starts_with.len)"},
{"lineNum":"  638","line":"        actual[0..expected_starts_with.len]"},
{"lineNum":"  639","line":"    else"},
{"lineNum":"  640","line":"        actual;"},
{"lineNum":"  641","line":""},
{"lineNum":"  642","line":"    print(\"\\n====== expected to start with: =========\\n\", .{});"},
{"lineNum":"  643","line":"    printWithVisibleNewlines(expected_starts_with);"},
{"lineNum":"  644","line":"    print(\"\\n====== instead started with: ===========\\n\", .{});"},
{"lineNum":"  645","line":"    printWithVisibleNewlines(shortened_actual);"},
{"lineNum":"  646","line":"    print(\"\\n========= full output: ==============\\n\", .{});"},
{"lineNum":"  647","line":"    printWithVisibleNewlines(actual);"},
{"lineNum":"  648","line":"    print(\"\\n======================================\\n\", .{});"},
{"lineNum":"  649","line":""},
{"lineNum":"  650","line":"    return error.TestExpectedStartsWith;"},
{"lineNum":"  651","line":"}"},
{"lineNum":"  652","line":""},
{"lineNum":"  653","line":"pub fn expectStringEndsWith(actual: []const u8, expected_ends_with: []const u8) !void {"},
{"lineNum":"  654","line":"    if (std.mem.endsWith(u8, actual, expected_ends_with))"},
{"lineNum":"  655","line":"        return;"},
{"lineNum":"  656","line":""},
{"lineNum":"  657","line":"    const shortened_actual = if (actual.len >= expected_ends_with.len)"},
{"lineNum":"  658","line":"        actual[(actual.len - expected_ends_with.len)..]"},
{"lineNum":"  659","line":"    else"},
{"lineNum":"  660","line":"        actual;"},
{"lineNum":"  661","line":""},
{"lineNum":"  662","line":"    print(\"\\n====== expected to end with: =========\\n\", .{});"},
{"lineNum":"  663","line":"    printWithVisibleNewlines(expected_ends_with);"},
{"lineNum":"  664","line":"    print(\"\\n====== instead ended with: ===========\\n\", .{});"},
{"lineNum":"  665","line":"    printWithVisibleNewlines(shortened_actual);"},
{"lineNum":"  666","line":"    print(\"\\n========= full output: ==============\\n\", .{});"},
{"lineNum":"  667","line":"    printWithVisibleNewlines(actual);"},
{"lineNum":"  668","line":"    print(\"\\n======================================\\n\", .{});"},
{"lineNum":"  669","line":""},
{"lineNum":"  670","line":"    return error.TestExpectedEndsWith;"},
{"lineNum":"  671","line":"}"},
{"lineNum":"  672","line":""},
{"lineNum":"  673","line":"/// This function is intended to be used only in tests. When the two values are not"},
{"lineNum":"  674","line":"/// deeply equal, prints diagnostics to stderr to show exactly how they are not equal,"},
{"lineNum":"  675","line":"/// then returns a test failure error."},
{"lineNum":"  676","line":"/// `actual` is casted to the type of `expected`."},
{"lineNum":"  677","line":"///"},
{"lineNum":"  678","line":"/// Deeply equal is defined as follows:"},
{"lineNum":"  679","line":"/// Primitive types are deeply equal if they are equal using  `==` operator."},
{"lineNum":"  680","line":"/// Struct values are deeply equal if their corresponding fields are deeply equal."},
{"lineNum":"  681","line":"/// Container types(like Array/Slice/Vector) deeply equal when their corresponding elements are deeply equal."},
{"lineNum":"  682","line":"/// Pointer values are deeply equal if values they point to are deeply equal."},
{"lineNum":"  683","line":"///"},
{"lineNum":"  684","line":"/// Note: Self-referential structs are not supported (e.g. things like std.SinglyLinkedList)"},
{"lineNum":"  685","line":"pub fn expectEqualDeep(expected: anytype, actual: @TypeOf(expected)) !void {"},
{"lineNum":"  686","line":"    switch (@typeInfo(@TypeOf(actual))) {"},
{"lineNum":"  687","line":"        .NoReturn,"},
{"lineNum":"  688","line":"        .Opaque,"},
{"lineNum":"  689","line":"        .Frame,"},
{"lineNum":"  690","line":"        .AnyFrame,"},
{"lineNum":"  691","line":"        => @compileError(\"value of type \" ++ @typeName(@TypeOf(actual)) ++ \" encountered\"),"},
{"lineNum":"  692","line":""},
{"lineNum":"  693","line":"        .Undefined,"},
{"lineNum":"  694","line":"        .Null,"},
{"lineNum":"  695","line":"        .Void,"},
{"lineNum":"  696","line":"        => return,"},
{"lineNum":"  697","line":""},
{"lineNum":"  698","line":"        .Type => {"},
{"lineNum":"  699","line":"            if (actual != expected) {"},
{"lineNum":"  700","line":"                std.debug.print(\"expected type {s}, found type {s}\\n\", .{ @typeName(expected), @typeName(actual) });"},
{"lineNum":"  701","line":"                return error.TestExpectedEqual;"},
{"lineNum":"  702","line":"            }"},
{"lineNum":"  703","line":"        },"},
{"lineNum":"  704","line":""},
{"lineNum":"  705","line":"        .Bool,"},
{"lineNum":"  706","line":"        .Int,"},
{"lineNum":"  707","line":"        .Float,"},
{"lineNum":"  708","line":"        .ComptimeFloat,"},
{"lineNum":"  709","line":"        .ComptimeInt,"},
{"lineNum":"  710","line":"        .EnumLiteral,"},
{"lineNum":"  711","line":"        .Enum,"},
{"lineNum":"  712","line":"        .Fn,"},
{"lineNum":"  713","line":"        .ErrorSet,"},
{"lineNum":"  714","line":"        => {"},
{"lineNum":"  715","line":"            if (actual != expected) {"},
{"lineNum":"  716","line":"                std.debug.print(\"expected {}, found {}\\n\", .{ expected, actual });"},
{"lineNum":"  717","line":"                return error.TestExpectedEqual;"},
{"lineNum":"  718","line":"            }"},
{"lineNum":"  719","line":"        },"},
{"lineNum":"  720","line":""},
{"lineNum":"  721","line":"        .Pointer => |pointer| {"},
{"lineNum":"  722","line":"            switch (pointer.size) {"},
{"lineNum":"  723","line":"                // We have no idea what is behind those pointers, so the best we can do is `==` check."},
{"lineNum":"  724","line":"                .C, .Many => {"},
{"lineNum":"  725","line":"                    if (actual != expected) {"},
{"lineNum":"  726","line":"                        std.debug.print(\"expected {*}, found {*}\\n\", .{ expected, actual });"},
{"lineNum":"  727","line":"                        return error.TestExpectedEqual;"},
{"lineNum":"  728","line":"                    }"},
{"lineNum":"  729","line":"                },"},
{"lineNum":"  730","line":"                .One => {"},
{"lineNum":"  731","line":"                    // Length of those pointers are runtime value, so the best we can do is `==` check."},
{"lineNum":"  732","line":"                    switch (@typeInfo(pointer.child)) {"},
{"lineNum":"  733","line":"                        .Fn, .Opaque => {"},
{"lineNum":"  734","line":"                            if (actual != expected) {"},
{"lineNum":"  735","line":"                                std.debug.print(\"expected {*}, found {*}\\n\", .{ expected, actual });"},
{"lineNum":"  736","line":"                                return error.TestExpectedEqual;"},
{"lineNum":"  737","line":"                            }"},
{"lineNum":"  738","line":"                        },"},
{"lineNum":"  739","line":"                        else => try expectEqualDeep(expected.*, actual.*),"},
{"lineNum":"  740","line":"                    }"},
{"lineNum":"  741","line":"                },"},
{"lineNum":"  742","line":"                .Slice => {"},
{"lineNum":"  743","line":"                    if (expected.len != actual.len) {"},
{"lineNum":"  744","line":"                        std.debug.print(\"Slice len not the same, expected {d}, found {d}\\n\", .{ expected.len, actual.len });"},
{"lineNum":"  745","line":"                        return error.TestExpectedEqual;"},
{"lineNum":"  746","line":"                    }"},
{"lineNum":"  747","line":"                    var i: usize = 0;"},
{"lineNum":"  748","line":"                    while (i < expected.len) : (i += 1) {"},
{"lineNum":"  749","line":"                        expectEqualDeep(expected[i], actual[i]) catch |e| {"},
{"lineNum":"  750","line":"                            std.debug.print(\"index {d} incorrect. expected {any}, found {any}\\n\", .{"},
{"lineNum":"  751","line":"                                i, expected[i], actual[i],"},
{"lineNum":"  752","line":"                            });"},
{"lineNum":"  753","line":"                            return e;"},
{"lineNum":"  754","line":"                        };"},
{"lineNum":"  755","line":"                    }"},
{"lineNum":"  756","line":"                },"},
{"lineNum":"  757","line":"            }"},
{"lineNum":"  758","line":"        },"},
{"lineNum":"  759","line":""},
{"lineNum":"  760","line":"        .Array => |_| {"},
{"lineNum":"  761","line":"            if (expected.len != actual.len) {"},
{"lineNum":"  762","line":"                std.debug.print(\"Array len not the same, expected {d}, found {d}\\n\", .{ expected.len, actual.len });"},
{"lineNum":"  763","line":"                return error.TestExpectedEqual;"},
{"lineNum":"  764","line":"            }"},
{"lineNum":"  765","line":"            var i: usize = 0;"},
{"lineNum":"  766","line":"            while (i < expected.len) : (i += 1) {"},
{"lineNum":"  767","line":"                expectEqualDeep(expected[i], actual[i]) catch |e| {"},
{"lineNum":"  768","line":"                    std.debug.print(\"index {d} incorrect. expected {any}, found {any}\\n\", .{"},
{"lineNum":"  769","line":"                        i, expected[i], actual[i],"},
{"lineNum":"  770","line":"                    });"},
{"lineNum":"  771","line":"                    return e;"},
{"lineNum":"  772","line":"                };"},
{"lineNum":"  773","line":"            }"},
{"lineNum":"  774","line":"        },"},
{"lineNum":"  775","line":""},
{"lineNum":"  776","line":"        .Vector => |info| {"},
{"lineNum":"  777","line":"            if (info.len != @typeInfo(@TypeOf(actual)).Vector.len) {"},
{"lineNum":"  778","line":"                std.debug.print(\"Vector len not the same, expected {d}, found {d}\\n\", .{ info.len, @typeInfo(@TypeOf(actual)).Vector.len });"},
{"lineNum":"  779","line":"                return error.TestExpectedEqual;"},
{"lineNum":"  780","line":"            }"},
{"lineNum":"  781","line":"            var i: usize = 0;"},
{"lineNum":"  782","line":"            while (i < info.len) : (i += 1) {"},
{"lineNum":"  783","line":"                expectEqualDeep(expected[i], actual[i]) catch |e| {"},
{"lineNum":"  784","line":"                    std.debug.print(\"index {d} incorrect. expected {any}, found {any}\\n\", .{"},
{"lineNum":"  785","line":"                        i, expected[i], actual[i],"},
{"lineNum":"  786","line":"                    });"},
{"lineNum":"  787","line":"                    return e;"},
{"lineNum":"  788","line":"                };"},
{"lineNum":"  789","line":"            }"},
{"lineNum":"  790","line":"        },"},
{"lineNum":"  791","line":""},
{"lineNum":"  792","line":"        .Struct => |structType| {"},
{"lineNum":"  793","line":"            inline for (structType.fields) |field| {"},
{"lineNum":"  794","line":"                expectEqualDeep(@field(expected, field.name), @field(actual, field.name)) catch |e| {"},
{"lineNum":"  795","line":"                    std.debug.print(\"Field {s} incorrect. expected {any}, found {any}\\n\", .{ field.name, @field(expected, field.name), @field(actual, field.name) });"},
{"lineNum":"  796","line":"                    return e;"},
{"lineNum":"  797","line":"                };"},
{"lineNum":"  798","line":"            }"},
{"lineNum":"  799","line":"        },"},
{"lineNum":"  800","line":""},
{"lineNum":"  801","line":"        .Union => |union_info| {"},
{"lineNum":"  802","line":"            if (union_info.tag_type == null) {"},
{"lineNum":"  803","line":"                @compileError(\"Unable to compare untagged union values\");"},
{"lineNum":"  804","line":"            }"},
{"lineNum":"  805","line":""},
{"lineNum":"  806","line":"            const Tag = std.meta.Tag(@TypeOf(expected));"},
{"lineNum":"  807","line":""},
{"lineNum":"  808","line":"            const expectedTag = @as(Tag, expected);"},
{"lineNum":"  809","line":"            const actualTag = @as(Tag, actual);"},
{"lineNum":"  810","line":""},
{"lineNum":"  811","line":"            try expectEqual(expectedTag, actualTag);"},
{"lineNum":"  812","line":""},
{"lineNum":"  813","line":"            // we only reach this loop if the tags are equal"},
{"lineNum":"  814","line":"            switch (expected) {"},
{"lineNum":"  815","line":"                inline else => |val, tag| {"},
{"lineNum":"  816","line":"                    try expectEqualDeep(val, @field(actual, @tagName(tag)));"},
{"lineNum":"  817","line":"                },"},
{"lineNum":"  818","line":"            }"},
{"lineNum":"  819","line":"        },"},
{"lineNum":"  820","line":""},
{"lineNum":"  821","line":"        .Optional => {"},
{"lineNum":"  822","line":"            if (expected) |expected_payload| {"},
{"lineNum":"  823","line":"                if (actual) |actual_payload| {"},
{"lineNum":"  824","line":"                    try expectEqualDeep(expected_payload, actual_payload);"},
{"lineNum":"  825","line":"                } else {"},
{"lineNum":"  826","line":"                    std.debug.print(\"expected {any}, found null\\n\", .{expected_payload});"},
{"lineNum":"  827","line":"                    return error.TestExpectedEqual;"},
{"lineNum":"  828","line":"                }"},
{"lineNum":"  829","line":"            } else {"},
{"lineNum":"  830","line":"                if (actual) |actual_payload| {"},
{"lineNum":"  831","line":"                    std.debug.print(\"expected null, found {any}\\n\", .{actual_payload});"},
{"lineNum":"  832","line":"                    return error.TestExpectedEqual;"},
{"lineNum":"  833","line":"                }"},
{"lineNum":"  834","line":"            }"},
{"lineNum":"  835","line":"        },"},
{"lineNum":"  836","line":""},
{"lineNum":"  837","line":"        .ErrorUnion => {"},
{"lineNum":"  838","line":"            if (expected) |expected_payload| {"},
{"lineNum":"  839","line":"                if (actual) |actual_payload| {"},
{"lineNum":"  840","line":"                    try expectEqualDeep(expected_payload, actual_payload);"},
{"lineNum":"  841","line":"                } else |actual_err| {"},
{"lineNum":"  842","line":"                    std.debug.print(\"expected {any}, found {any}\\n\", .{ expected_payload, actual_err });"},
{"lineNum":"  843","line":"                    return error.TestExpectedEqual;"},
{"lineNum":"  844","line":"                }"},
{"lineNum":"  845","line":"            } else |expected_err| {"},
{"lineNum":"  846","line":"                if (actual) |actual_payload| {"},
{"lineNum":"  847","line":"                    std.debug.print(\"expected {any}, found {any}\\n\", .{ expected_err, actual_payload });"},
{"lineNum":"  848","line":"                    return error.TestExpectedEqual;"},
{"lineNum":"  849","line":"                } else |actual_err| {"},
{"lineNum":"  850","line":"                    try expectEqualDeep(expected_err, actual_err);"},
{"lineNum":"  851","line":"                }"},
{"lineNum":"  852","line":"            }"},
{"lineNum":"  853","line":"        },"},
{"lineNum":"  854","line":"    }"},
{"lineNum":"  855","line":"}"},
{"lineNum":"  856","line":""},
{"lineNum":"  857","line":"test \"expectEqualDeep primitive type\" {"},
{"lineNum":"  858","line":"    try expectEqualDeep(1, 1);"},
{"lineNum":"  859","line":"    try expectEqualDeep(true, true);"},
{"lineNum":"  860","line":"    try expectEqualDeep(1.5, 1.5);"},
{"lineNum":"  861","line":"    try expectEqualDeep(u8, u8);"},
{"lineNum":"  862","line":"    try expectEqualDeep(error.Bad, error.Bad);"},
{"lineNum":"  863","line":""},
{"lineNum":"  864","line":"    // optional"},
{"lineNum":"  865","line":"    {"},
{"lineNum":"  866","line":"        const foo: ?u32 = 1;"},
{"lineNum":"  867","line":"        const bar: ?u32 = 1;"},
{"lineNum":"  868","line":"        try expectEqualDeep(foo, bar);"},
{"lineNum":"  869","line":"        try expectEqualDeep(?u32, ?u32);"},
{"lineNum":"  870","line":"    }"},
{"lineNum":"  871","line":"    // function type"},
{"lineNum":"  872","line":"    {"},
{"lineNum":"  873","line":"        const fnType = struct {"},
{"lineNum":"  874","line":"            fn foo() void {"},
{"lineNum":"  875","line":"                unreachable;"},
{"lineNum":"  876","line":"            }"},
{"lineNum":"  877","line":"        }.foo;"},
{"lineNum":"  878","line":"        try expectEqualDeep(fnType, fnType);"},
{"lineNum":"  879","line":"    }"},
{"lineNum":"  880","line":"}"},
{"lineNum":"  881","line":""},
{"lineNum":"  882","line":"test \"expectEqualDeep pointer\" {"},
{"lineNum":"  883","line":"    const a = 1;"},
{"lineNum":"  884","line":"    const b = 1;"},
{"lineNum":"  885","line":"    try expectEqualDeep(&a, &b);"},
{"lineNum":"  886","line":"}"},
{"lineNum":"  887","line":""},
{"lineNum":"  888","line":"test \"expectEqualDeep composite type\" {"},
{"lineNum":"  889","line":"    try expectEqualDeep(\"abc\", \"abc\");"},
{"lineNum":"  890","line":"    const s1: []const u8 = \"abc\";"},
{"lineNum":"  891","line":"    const s2 = \"abcd\";"},
{"lineNum":"  892","line":"    const s3: []const u8 = s2[0..3];"},
{"lineNum":"  893","line":"    try expectEqualDeep(s1, s3);"},
{"lineNum":"  894","line":""},
{"lineNum":"  895","line":"    const TestStruct = struct { s: []const u8 };"},
{"lineNum":"  896","line":"    try expectEqualDeep(TestStruct{ .s = \"abc\" }, TestStruct{ .s = \"abc\" });"},
{"lineNum":"  897","line":"    try expectEqualDeep([_][]const u8{ \"a\", \"b\", \"c\" }, [_][]const u8{ \"a\", \"b\", \"c\" });"},
{"lineNum":"  898","line":""},
{"lineNum":"  899","line":"    // vector"},
{"lineNum":"  900","line":"    try expectEqualDeep(@splat(4, @as(u32, 4)), @splat(4, @as(u32, 4)));"},
{"lineNum":"  901","line":""},
{"lineNum":"  902","line":"    // nested array"},
{"lineNum":"  903","line":"    {"},
{"lineNum":"  904","line":"        const a = [2][2]f32{"},
{"lineNum":"  905","line":"            [_]f32{ 1.0, 0.0 },"},
{"lineNum":"  906","line":"            [_]f32{ 0.0, 1.0 },"},
{"lineNum":"  907","line":"        };"},
{"lineNum":"  908","line":""},
{"lineNum":"  909","line":"        const b = [2][2]f32{"},
{"lineNum":"  910","line":"            [_]f32{ 1.0, 0.0 },"},
{"lineNum":"  911","line":"            [_]f32{ 0.0, 1.0 },"},
{"lineNum":"  912","line":"        };"},
{"lineNum":"  913","line":""},
{"lineNum":"  914","line":"        try expectEqualDeep(a, b);"},
{"lineNum":"  915","line":"        try expectEqualDeep(&a, &b);"},
{"lineNum":"  916","line":"    }"},
{"lineNum":"  917","line":"}"},
{"lineNum":"  918","line":""},
{"lineNum":"  919","line":"fn printIndicatorLine(source: []const u8, indicator_index: usize) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  920","line":"    const line_begin_index = if (std.mem.lastIndexOfScalar(u8, source[0..indicator_index], \'\\n\')) |line_begin|","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  921","line":"        line_begin + 1","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  922","line":"    else"},
{"lineNum":"  923","line":"        0;"},
{"lineNum":"  924","line":"    const line_end_index = if (std.mem.indexOfScalar(u8, source[indicator_index..], \'\\n\')) |line_end|","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  925","line":"        (indicator_index + line_end)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  926","line":"    else"},
{"lineNum":"  927","line":"        source.len;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  928","line":""},
{"lineNum":"  929","line":"    printLine(source[line_begin_index..line_end_index]);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  930","line":"    {"},
{"lineNum":"  931","line":"        var i: usize = line_begin_index;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  932","line":"        while (i < indicator_index) : (i += 1)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  933","line":"            print(\" \", .{});","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  934","line":"    }"},
{"lineNum":"  935","line":"    if (indicator_index >= source.len)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  936","line":"        print(\"^ (end of string)\\n\", .{})","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  937","line":"    else"},
{"lineNum":"  938","line":"        print(\"^ (\'\\\\x{x:0>2}\')\\n\", .{source[indicator_index]});","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  939","line":"}"},
{"lineNum":"  940","line":""},
{"lineNum":"  941","line":"fn printWithVisibleNewlines(source: []const u8) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  942","line":"    var i: usize = 0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  943","line":"    while (std.mem.indexOfScalar(u8, source[i..], \'\\n\')) |nl| : (i += nl + 1) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  944","line":"        printLine(source[i .. i + nl]);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  945","line":"    }"},
{"lineNum":"  946","line":"    print(\"{s}\\n\", .{source[i..]}); // End of Text symbol (ETX)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  947","line":"}"},
{"lineNum":"  948","line":""},
{"lineNum":"  949","line":"fn printLine(line: []const u8) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  950","line":"    if (line.len != 0) switch (line[line.len - 1]) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  951","line":"        \' \', \'\\t\' => return print(\"{s}\\n\", .{line}), // Carriage return symbol,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  952","line":"        else => {},"},
{"lineNum":"  953","line":"    };"},
{"lineNum":"  954","line":"    print(\"{s}\\n\", .{line});","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  955","line":"}"},
{"lineNum":"  956","line":""},
{"lineNum":"  957","line":"test {"},
{"lineNum":"  958","line":"    try expectEqualStrings(\"foo\", \"foo\");"},
{"lineNum":"  959","line":"}"},
{"lineNum":"  960","line":""},
{"lineNum":"  961","line":"/// Exhaustively check that allocation failures within `test_fn` are handled without"},
{"lineNum":"  962","line":"/// introducing memory leaks. If used with the `testing.allocator` as the `backing_allocator`,"},
{"lineNum":"  963","line":"/// it will also be able to detect double frees, etc (when runtime safety is enabled)."},
{"lineNum":"  964","line":"///"},
{"lineNum":"  965","line":"/// The provided `test_fn` must have a `std.mem.Allocator` as its first argument,"},
{"lineNum":"  966","line":"/// and must have a return type of `!void`. Any extra arguments of `test_fn` can"},
{"lineNum":"  967","line":"/// be provided via the `extra_args` tuple."},
{"lineNum":"  968","line":"///"},
{"lineNum":"  969","line":"/// Any relevant state shared between runs of `test_fn` *must* be reset within `test_fn`."},
{"lineNum":"  970","line":"///"},
{"lineNum":"  971","line":"/// The strategy employed is to:"},
{"lineNum":"  972","line":"/// - Run the test function once to get the total number of allocations."},
{"lineNum":"  973","line":"/// - Then, iterate and run the function X more times, incrementing"},
{"lineNum":"  974","line":"///   the failing index each iteration (where X is the total number of"},
{"lineNum":"  975","line":"///   allocations determined previously)"},
{"lineNum":"  976","line":"///"},
{"lineNum":"  977","line":"/// Expects that `test_fn` has a deterministic number of memory allocations:"},
{"lineNum":"  978","line":"/// - If an allocation was made to fail during a run of `test_fn`, but `test_fn`"},
{"lineNum":"  979","line":"///   didn\'t return `error.OutOfMemory`, then `error.SwallowedOutOfMemoryError`"},
{"lineNum":"  980","line":"///   is returned from `checkAllAllocationFailures`. You may want to ignore this"},
{"lineNum":"  981","line":"///   depending on whether or not the code you\'re testing includes some strategies"},
{"lineNum":"  982","line":"///   for recovering from `error.OutOfMemory`."},
{"lineNum":"  983","line":"/// - If a run of `test_fn` with an expected allocation failure executes without"},
{"lineNum":"  984","line":"///   an allocation failure being induced, then `error.NondeterministicMemoryUsage`"},
{"lineNum":"  985","line":"///   is returned. This error means that there are allocation points that won\'t be"},
{"lineNum":"  986","line":"///   tested by the strategy this function employs (that is, there are sometimes more"},
{"lineNum":"  987","line":"///   points of allocation than the initial run of `test_fn` detects)."},
{"lineNum":"  988","line":"///"},
{"lineNum":"  989","line":"/// ---"},
{"lineNum":"  990","line":"///"},
{"lineNum":"  991","line":"/// Here\'s an example using a simple test case that will cause a leak when the"},
{"lineNum":"  992","line":"/// allocation of `bar` fails (but will pass normally):"},
{"lineNum":"  993","line":"///"},
{"lineNum":"  994","line":"/// ```zig"},
{"lineNum":"  995","line":"/// test {"},
{"lineNum":"  996","line":"///     const length: usize = 10;"},
{"lineNum":"  997","line":"///     const allocator = std.testing.allocator;"},
{"lineNum":"  998","line":"///     var foo = try allocator.alloc(u8, length);"},
{"lineNum":"  999","line":"///     var bar = try allocator.alloc(u8, length);"},
{"lineNum":" 1000","line":"///"},
{"lineNum":" 1001","line":"///     allocator.free(foo);"},
{"lineNum":" 1002","line":"///     allocator.free(bar);"},
{"lineNum":" 1003","line":"/// }"},
{"lineNum":" 1004","line":"/// ```"},
{"lineNum":" 1005","line":"///"},
{"lineNum":" 1006","line":"/// The test case can be converted to something that this function can use by"},
{"lineNum":" 1007","line":"/// doing:"},
{"lineNum":" 1008","line":"///"},
{"lineNum":" 1009","line":"/// ```zig"},
{"lineNum":" 1010","line":"/// fn testImpl(allocator: std.mem.Allocator, length: usize) !void {"},
{"lineNum":" 1011","line":"///     var foo = try allocator.alloc(u8, length);"},
{"lineNum":" 1012","line":"///     var bar = try allocator.alloc(u8, length);"},
{"lineNum":" 1013","line":"///"},
{"lineNum":" 1014","line":"///     allocator.free(foo);"},
{"lineNum":" 1015","line":"///     allocator.free(bar);"},
{"lineNum":" 1016","line":"/// }"},
{"lineNum":" 1017","line":"///"},
{"lineNum":" 1018","line":"/// test {"},
{"lineNum":" 1019","line":"///     const length: usize = 10;"},
{"lineNum":" 1020","line":"///     const allocator = std.testing.allocator;"},
{"lineNum":" 1021","line":"///     try std.testing.checkAllAllocationFailures(allocator, testImpl, .{length});"},
{"lineNum":" 1022","line":"/// }"},
{"lineNum":" 1023","line":"/// ```"},
{"lineNum":" 1024","line":"///"},
{"lineNum":" 1025","line":"/// Running this test will show that `foo` is leaked when the allocation of"},
{"lineNum":" 1026","line":"/// `bar` fails. The simplest fix, in this case, would be to use defer like so:"},
{"lineNum":" 1027","line":"///"},
{"lineNum":" 1028","line":"/// ```zig"},
{"lineNum":" 1029","line":"/// fn testImpl(allocator: std.mem.Allocator, length: usize) !void {"},
{"lineNum":" 1030","line":"///     var foo = try allocator.alloc(u8, length);"},
{"lineNum":" 1031","line":"///     defer allocator.free(foo);"},
{"lineNum":" 1032","line":"///     var bar = try allocator.alloc(u8, length);"},
{"lineNum":" 1033","line":"///     defer allocator.free(bar);"},
{"lineNum":" 1034","line":"/// }"},
{"lineNum":" 1035","line":"/// ```"},
{"lineNum":" 1036","line":"pub fn checkAllAllocationFailures(backing_allocator: std.mem.Allocator, comptime test_fn: anytype, extra_args: anytype) !void {"},
{"lineNum":" 1037","line":"    switch (@typeInfo(@typeInfo(@TypeOf(test_fn)).Fn.return_type.?)) {"},
{"lineNum":" 1038","line":"        .ErrorUnion => |info| {"},
{"lineNum":" 1039","line":"            if (info.payload != void) {"},
{"lineNum":" 1040","line":"                @compileError(\"Return type must be !void\");"},
{"lineNum":" 1041","line":"            }"},
{"lineNum":" 1042","line":"        },"},
{"lineNum":" 1043","line":"        else => @compileError(\"Return type must be !void\"),"},
{"lineNum":" 1044","line":"    }"},
{"lineNum":" 1045","line":"    if (@typeInfo(@TypeOf(extra_args)) != .Struct) {"},
{"lineNum":" 1046","line":"        @compileError(\"Expected tuple or struct argument, found \" ++ @typeName(@TypeOf(extra_args)));"},
{"lineNum":" 1047","line":"    }"},
{"lineNum":" 1048","line":""},
{"lineNum":" 1049","line":"    const ArgsTuple = std.meta.ArgsTuple(@TypeOf(test_fn));"},
{"lineNum":" 1050","line":"    const fn_args_fields = @typeInfo(ArgsTuple).Struct.fields;"},
{"lineNum":" 1051","line":"    if (fn_args_fields.len == 0 or fn_args_fields[0].type != std.mem.Allocator) {"},
{"lineNum":" 1052","line":"        @compileError(\"The provided function must have an \" ++ @typeName(std.mem.Allocator) ++ \" as its first argument\");"},
{"lineNum":" 1053","line":"    }"},
{"lineNum":" 1054","line":"    const expected_args_tuple_len = fn_args_fields.len - 1;"},
{"lineNum":" 1055","line":"    if (extra_args.len != expected_args_tuple_len) {"},
{"lineNum":" 1056","line":"        @compileError(\"The provided function expects \" ++ std.fmt.comptimePrint(\"{d}\", .{expected_args_tuple_len}) ++ \" extra arguments, but the provided tuple contains \" ++ std.fmt.comptimePrint(\"{d}\", .{extra_args.len}));"},
{"lineNum":" 1057","line":"    }"},
{"lineNum":" 1058","line":""},
{"lineNum":" 1059","line":"    // Setup the tuple that will actually be used with @call (we\'ll need to insert"},
{"lineNum":" 1060","line":"    // the failing allocator in field @\"0\" before each @call)"},
{"lineNum":" 1061","line":"    var args: ArgsTuple = undefined;"},
{"lineNum":" 1062","line":"    inline for (@typeInfo(@TypeOf(extra_args)).Struct.fields, 0..) |field, i| {"},
{"lineNum":" 1063","line":"        const arg_i_str = comptime str: {"},
{"lineNum":" 1064","line":"            var str_buf: [100]u8 = undefined;"},
{"lineNum":" 1065","line":"            const args_i = i + 1;"},
{"lineNum":" 1066","line":"            const str_len = std.fmt.formatIntBuf(&str_buf, args_i, 10, .lower, .{});"},
{"lineNum":" 1067","line":"            break :str str_buf[0..str_len];"},
{"lineNum":" 1068","line":"        };"},
{"lineNum":" 1069","line":"        @field(args, arg_i_str) = @field(extra_args, field.name);"},
{"lineNum":" 1070","line":"    }"},
{"lineNum":" 1071","line":""},
{"lineNum":" 1072","line":"    // Try it once with unlimited memory, make sure it works"},
{"lineNum":" 1073","line":"    const needed_alloc_count = x: {"},
{"lineNum":" 1074","line":"        var failing_allocator_inst = std.testing.FailingAllocator.init(backing_allocator, std.math.maxInt(usize));"},
{"lineNum":" 1075","line":"        args.@\"0\" = failing_allocator_inst.allocator();"},
{"lineNum":" 1076","line":""},
{"lineNum":" 1077","line":"        try @call(.auto, test_fn, args);"},
{"lineNum":" 1078","line":"        break :x failing_allocator_inst.index;"},
{"lineNum":" 1079","line":"    };"},
{"lineNum":" 1080","line":""},
{"lineNum":" 1081","line":"    var fail_index: usize = 0;"},
{"lineNum":" 1082","line":"    while (fail_index < needed_alloc_count) : (fail_index += 1) {"},
{"lineNum":" 1083","line":"        var failing_allocator_inst = std.testing.FailingAllocator.init(backing_allocator, fail_index);"},
{"lineNum":" 1084","line":"        args.@\"0\" = failing_allocator_inst.allocator();"},
{"lineNum":" 1085","line":""},
{"lineNum":" 1086","line":"        if (@call(.auto, test_fn, args)) |_| {"},
{"lineNum":" 1087","line":"            if (failing_allocator_inst.has_induced_failure) {"},
{"lineNum":" 1088","line":"                return error.SwallowedOutOfMemoryError;"},
{"lineNum":" 1089","line":"            } else {"},
{"lineNum":" 1090","line":"                return error.NondeterministicMemoryUsage;"},
{"lineNum":" 1091","line":"            }"},
{"lineNum":" 1092","line":"        } else |err| switch (err) {"},
{"lineNum":" 1093","line":"            error.OutOfMemory => {"},
{"lineNum":" 1094","line":"                if (failing_allocator_inst.allocated_bytes != failing_allocator_inst.freed_bytes) {"},
{"lineNum":" 1095","line":"                    print("},
{"lineNum":" 1096","line":"                        \"\\nfail_index: {d}/{d}\\nallocated bytes: {d}\\nfreed bytes: {d}\\nallocations: {d}\\ndeallocations: {d}\\nallocation that was made to fail: {}\","},
{"lineNum":" 1097","line":"                        .{"},
{"lineNum":" 1098","line":"                            fail_index,"},
{"lineNum":" 1099","line":"                            needed_alloc_count,"},
{"lineNum":" 1100","line":"                            failing_allocator_inst.allocated_bytes,"},
{"lineNum":" 1101","line":"                            failing_allocator_inst.freed_bytes,"},
{"lineNum":" 1102","line":"                            failing_allocator_inst.allocations,"},
{"lineNum":" 1103","line":"                            failing_allocator_inst.deallocations,"},
{"lineNum":" 1104","line":"                            failing_allocator_inst.getStackTrace(),"},
{"lineNum":" 1105","line":"                        },"},
{"lineNum":" 1106","line":"                    );"},
{"lineNum":" 1107","line":"                    return error.MemoryLeakDetected;"},
{"lineNum":" 1108","line":"                }"},
{"lineNum":" 1109","line":"            },"},
{"lineNum":" 1110","line":"            else => return err,"},
{"lineNum":" 1111","line":"        }"},
{"lineNum":" 1112","line":"    }"},
{"lineNum":" 1113","line":"}"},
{"lineNum":" 1114","line":""},
{"lineNum":" 1115","line":"/// Given a type, references all the declarations inside, so that the semantic analyzer sees them."},
{"lineNum":" 1116","line":"pub fn refAllDecls(comptime T: type) void {"},
{"lineNum":" 1117","line":"    if (!builtin.is_test) return;"},
{"lineNum":" 1118","line":"    inline for (comptime std.meta.declarations(T)) |decl| {"},
{"lineNum":" 1119","line":"        if (decl.is_pub) _ = @field(T, decl.name);"},
{"lineNum":" 1120","line":"    }"},
{"lineNum":" 1121","line":"}"},
{"lineNum":" 1122","line":""},
{"lineNum":" 1123","line":"/// Given a type, recursively references all the declarations inside, so that the semantic analyzer sees them."},
{"lineNum":" 1124","line":"/// For deep types, you may use `@setEvalBranchQuota`."},
{"lineNum":" 1125","line":"pub fn refAllDeclsRecursive(comptime T: type) void {"},
{"lineNum":" 1126","line":"    if (!builtin.is_test) return;"},
{"lineNum":" 1127","line":"    inline for (comptime std.meta.declarations(T)) |decl| {"},
{"lineNum":" 1128","line":"        if (decl.is_pub) {"},
{"lineNum":" 1129","line":"            if (@TypeOf(@field(T, decl.name)) == type) {"},
{"lineNum":" 1130","line":"                switch (@typeInfo(@field(T, decl.name))) {"},
{"lineNum":" 1131","line":"                    .Struct, .Enum, .Union, .Opaque => refAllDeclsRecursive(@field(T, decl.name)),"},
{"lineNum":" 1132","line":"                    else => {},"},
{"lineNum":" 1133","line":"                }"},
{"lineNum":" 1134","line":"            }"},
{"lineNum":" 1135","line":"            _ = @field(T, decl.name);"},
{"lineNum":" 1136","line":"        }"},
{"lineNum":" 1137","line":"    }"},
{"lineNum":" 1138","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2023-04-18 20:41:50", "instrumented" : 50, "covered" : 8,};
var merged_data = [];
