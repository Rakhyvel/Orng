import mem
import testing

struct String_Buffer {
    // The internal character buffer
    buffer: ?[mut]Byte
    // The total size of the string
    size: Int
    // The allocator used for managing the buffer
    allocator: &mut dyn core::Allocator
}

enum Error {
    out_of_memory
    invalid_range
}

impl for String_Buffer {
    fn init() -> String_Buffer with core::Allocating {
        String_Buffer(.none, 0, core::Allocating.alloc)
    }

    fn init_with_contents(contents: String) -> Error!String_Buffer with core::Allocating {
        let mut string = String_Buffer::init()

        try string.>concat(contents)

        .ok(string)
    }

    fn deinit(&mut self) {
        match self.buffer {
            .some(buffer) => {
                self.allocator.>free(buffer.data)
                self.buffer = .none
            }
            .none => {}
        }
    }

    fn capacity(&self) -> Int {
        match self.buffer {
            .some(buffer) => buffer.length
            .none => 0
        }
    }
  
//    fn cmp(&self, literal: String) -> Bool {}
//
//    fn str(&self) -> String {}
//
//    fn toOwned(&self) -> Error!?[mut]Byte {}
//
//    fn char_at(&self, index: Int) -> ?String {}

    fn length(&self) -> Int {
        match self.buffer {
            .some(buffer) => {
                let mut l = 0
                while let mut i = 0; i < self.size {
                    i += utf8_byte_sequence_length(buffer[i])
                    l += 1
                }
                l
            }

            .none => 0
        }
    }

//    fn find(&self, literal: String) -> ?Int {}
//
//    fn clone(&self) -> Error!String_Buffer {}
//
//    fn is_empty(&self) -> Bool {}

    fn allocate(&mut self, bytes: Int) -> Error!() {
        match self.buffer {
            .some(buffer) => {
                if bytes < self.size {
                    self.size = bytes
                }
                let realloc: [*mut]Byte = self.allocator.>realloc(buffer.data, bytes) orelse {
                    return .err(.out_of_memory)
                }
                let slice = mem::slice_from_parts[Byte](realloc, bytes)
                self.buffer = .some(slice)
            }

            .none => {
                let alloc = self.allocator.>alloc(bytes) orelse {
                    return .err(.out_of_memory)
                }
                let slice = mem::slice_from_parts[Byte](alloc, bytes)
                self.buffer = .some(slice)
            }
        }
        
        .ok
    }

    fn concat(&mut self, char: String) -> Error!() {
        self.>insert(char, self.>length())
    }

    fn insert(&mut self, literal: String, index: Int) -> Error!() {
        // Make sure buffer has enough space
        match self.buffer {
            .some(buffer) => {
                if self.size + literal.length > buffer.length {
                    try self.>allocate((self.size + literal.length) * 2)
                }
            }
            .none => try self.>allocate((literal.length) * 2)
        }

        let buffer = self.buffer.some

        // If the index is >= length, then simply push to the end.
        // If not, then copy contents over and insert literal.
        if index == self.>length() {
            while let mut i = 0; i < literal.length; i += 1 {
                buffer[self.size + i] = literal[i]
            }
        } else {
            match get_index(buffer, index, true) {
                .some(k) => {
                    // Move existing contents over
                    while let mut i = buffer.length - 1; i >= k; i -= 1 {
                        if i + literal.length < buffer.length {
                            buffer[i + literal.length] = buffer[i]
                        }

                        if i == 0 {break}
                    }

                    while let mut i = 0; i < literal.length; i += 1 {
                        buffer[index + i] = literal[i]
                    }
                }

                .none => {}
            }
        }

        self.size += literal.length

        .ok
    }

//    fn remove(&mut self) {}
//
//    fn clear(&mut self) {}
//
//    fn to_lowercase(&mut self) {}
//
//    fn to_uppercase(&mut self) {}
//
//    fn replace(&mut self, needle: String, replacement: String) {}
}

test "length.ascii" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello, World!") catch {return .err}
    defer str.>deinit()

    try testing::expect(str.>length() == 13)
    try testing::expect(str.size == 13)

    .ok
}

test "length.unicode" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello, ðŸŒ!") catch {return .err}
    defer str.>deinit()

    try testing::expect(str.>length() == 9)
    try testing::expect(str.size == 12)

    .ok
}

// Returns the real index of a unicode string literal
fn get_index(unicode: String, index: Int, real: Bool) -> ?Int {
    let mut i = 0
    let mut j = 0
    while i < unicode.length {
        if real {
            if j == index {return .some(i)}
        } else {
            if i == index {return .some(j)}
        }
        i += utf8_byte_sequence_length(unicode[i])
        j += 1
    }

    .none
}

// Returns the total length in bytes of a codepoint, given the first byte
fn utf8_byte_sequence_length(first_byte: Byte) -> Int {
    if first_byte >= 0 and first_byte <= 0b0111_1111 {
        1
    } else if first_byte >= 0b1100_0000 and first_byte <= 0b1101_1111 {
        2
    } else if first_byte >= 0b1110_0000 and first_byte <= 0b1110_1111 {
        3
    } else if first_byte >= 0b1111_0000 and first_byte <= 0b1111_0111 {
        4
    } else {
        1
    }
}