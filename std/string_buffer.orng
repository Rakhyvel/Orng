import ascii
import mem
import testing
import debug

struct String_Buffer {
    // The internal character buffer
    buffer: ?[mut]Byte
    // The total size of the string
    size: Int
    // The allocator used for managing the buffer
    allocator: &mut dyn core::Allocator
}

enum Error {
    out_of_memory
    invalid_range
}

impl for String_Buffer {
    fn init() -> String_Buffer with core::Allocating {
        String_Buffer(.none, 0, core::Allocating.alloc)
    }

    fn init_with_contents(contents: String) -> Error!String_Buffer with core::Allocating {
        let mut string = String_Buffer::init()

        try string.>concat(contents)

        .ok(string)
    }

    fn deinit(&mut self) {
        match self.buffer {
            .some(buffer) => {
                self.allocator.>free(buffer.data)
                self.buffer = .none
            }
            .none => {}
        }
    }

    fn capacity(&self) -> Int {
        match self.buffer {
            .some(buffer) => buffer.length
            .none => 0
        }
    }
  
    fn cmp(&self, literal: String) -> Bool {
        match self.buffer {
            .some(buffer) => mem::eql(buffer[..self.size], literal)
            .none         => false
        }
    }

    fn str(&self) -> String {
        match self.buffer {
            .some(buffer) => buffer[..self.size]
            .none         => ""
        }
    }

    fn to_owned(&self) -> Error!?[mut]Byte {
        match self.buffer {
            .some(_) => {
                let string = self.>str()
                match self.allocator.>alloc(string.length) {
                    .some(bytes) => {
                        let new_str = mem::slice_from_parts[Byte](bytes, string.length)
                        mem::copy(new_str, string)
                        .ok(.some(new_str))
                    }
                    .none => .err(.out_of_memory)
                }
            }

            .none => .ok(.none)
        }
    }

    fn char_at(&self, index: Int) -> ?String {
        match self.buffer {
            .some(buffer) => {
                match get_index(buffer, index, true) {
                    .some(i) => {
                        let size = utf8_byte_sequence_length(buffer[i])
                        .some(buffer[i..(i + size)])
                    }
                    .none => .none
                }
            }

            .none => .none
        }
    }

    fn length(&self) -> Int {
        match self.buffer {
            .some(buffer) => {
                let mut l = 0
                while let mut i = 0; i < self.size {
                    i += utf8_byte_sequence_length(buffer[i])
                    l += 1
                }
                l
            }

            .none => 0
        }
    }

    fn find(&self, literal: String) -> ?Int {
        match self.buffer {
            .some(buffer) => {
                let index = mem::index_of(buffer[0..self.size], literal)
                match index {
                    .some(i) => get_index(buffer, i, false)
                    .none => .none
                }
            }

            .none => .none
        }
    }

    fn clone(&self) -> Error!String_Buffer {
        with core::Allocating(self.allocator) {
            let mut new_string = String_Buffer::init()
            try new_string.>concat(self.>str())
            .ok(new_string)
        }
    }

    fn is_empty(&self) -> Bool {
        self.size == 0
    }

    fn allocate(&mut self, bytes: Int) -> Error!() {
        match self.buffer {
            .some(buffer) => {
                if bytes < self.size {
                    self.size = bytes
                }
                let realloc: [*mut]Byte = self.allocator.>realloc(buffer.data, bytes) orelse {
                    return .err(.out_of_memory)
                }
                let slice = mem::slice_from_parts[Byte](realloc, bytes)
                self.buffer = .some(slice)
            }

            .none => {
                let alloc = self.allocator.>alloc(bytes) orelse {
                    return .err(.out_of_memory)
                }
                let slice = mem::slice_from_parts[Byte](alloc, bytes)
                self.buffer = .some(slice)
            }
        }
        
        .ok
    }

    fn concat(&mut self, char: String) -> Error!() {
        self.>insert(char, self.>length())
    }

    fn insert(&mut self, literal: String, index: Int) -> Error!() {
        // Make sure buffer has enough space
        match self.buffer {
            .some(buffer) => {
                if self.size + literal.length > buffer.length {
                    try self.>allocate((self.size + literal.length) * 2)
                }
            }
            .none => try self.>allocate((literal.length) * 2)
        }

        let buffer = self.buffer.some

        // If the index is >= length, then simply push to the end.
        // If not, then copy contents over and insert literal.
        if index == self.>length() {
            while let mut i = 0; i < literal.length; i += 1 {
                buffer[self.size + i] = literal[i]
            }
        } else {
            match get_index(buffer, index, true) {
                .some(k) => {
                    // Move existing contents over
                    while let mut i = buffer.length - 1; i >= k; i -= 1 {
                        if i + literal.length < buffer.length {
                            buffer[i + literal.length] = buffer[i]
                        }

                        if i == 0 {break}
                    }

                    while let mut i = 0; i < literal.length; i += 1 {
                        buffer[k + i] = literal[i]
                    }
                }

                .none => {}
            }
        }

        self.size += literal.length

        .ok
    }

    fn remove(&mut self, index: Int) -> Error!() {
        self.>remove_range(index, index + 1)
    }

    fn remove_range(&mut self, start: Int, end: Int) -> Error!() {
        let len = self.>length()
        if end < start or end > len {return .err(.invalid_range)}

        match self.buffer {
            .some(mut buffer) => {
                let rstart = get_index(buffer, start, true).some
                let rend = get_index(buffer, end, true).some
                let difference = rend - rstart

                while let mut i = rend; i < self.size; i += 1 {
                    buffer[i - difference] = buffer[i]
                }

                self.size -= difference
            }

            .none => {}
        }

        .ok
    }

    fn clear(&mut self) {
        match self.buffer {
            .some(mut buffer) => {
                while let mut i = 0; i < buffer.length; i += 1 {
                    buffer[i] = 0
                }

                self.size = 0
            }

            .none => {}
        }
    }

    fn to_lowercase(&mut self) {
        match self.buffer {
            .some(mut buffer) => {
                while let mut i = 0; i < self.size {
                    let size = utf8_byte_sequence_length(buffer[i])
                    if size == 1 { // implies ascii
                        buffer[i] = Byte::to_lower(buffer[i])
                    }
                    i += size
                }
            }

            .none => {}
        }
    }

    fn to_uppercase(&mut self) {
        match self.buffer {
            .some(mut buffer) => {
                while let mut i = 0; i < self.size {
                    let size = utf8_byte_sequence_length(buffer[i])
                    if size == 1 { // implies ascii
                        buffer[i] = Byte::to_upper(buffer[i])
                    }
                    i += size
                }
            }

            .none => {}
        }
    }

    fn replace(&mut self, needle: String, replacement: String) -> Error!Bool {
        match self.buffer {
            .some(mut buffer) => {
                let free_me = buffer.data
                defer self.allocator.>free(free_me)

                let input_size = self.size
                let size = mem::replacement_size(buffer[0..input_size], needle, replacement)

                let alloc = self.allocator.>alloc(size) orelse {
                    return .err(.out_of_memory)
                }
                let slice = mem::slice_from_parts[Byte](alloc, size)
                self.buffer = .some(slice)
                self.size = size

                let changes = mem::replace(buffer[0..input_size], needle, replacement, self.buffer.some)
                .ok(changes > 0)
            }

            .none => .ok(false)
        }
    }
}

test "capacity" with core::Allocating {
    let mut str = String_Buffer::init()
    defer str.>deinit()

    str.>allocate(16) catch {return .err}
    try testing::expect(str.>capacity() == 16)
    try testing::expect(str.size == 0)

    .ok
}

test "cmp" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello, World!") catch {return .err}
    defer str.>deinit()

    try testing::expect(str.>cmp("Hello, World!"))

    .ok
}

test "cmp2" with core::Allocating {
    let mut str1 = String_Buffer::init_with_contents("Hello, World!") catch {return .err}
    defer str1.>deinit()

    let mut str2 = String_Buffer::init_with_contents("Hello, World!") catch {return .err}
    defer str2.>deinit()

    try testing::expect(str1.>cmp(str2.>str()))

    .ok
}

test "to_owned" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello, World!") catch {return .err}
    defer str.>deinit()

    let slice = str.>to_owned().ok.some
    try testing::expect(str.>cmp(slice))

    .ok
}

test "char_at" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello, ðŸŒ!") catch {return .err}
    defer str.>deinit()

    try testing::expect(mem::eql(str.>char_at(2).some, "l"))
    try testing::expect(mem::eql(str.>char_at(7).some, "ðŸŒ"))

    .ok
}

test "length.ascii" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello, World!") catch {return .err}
    defer str.>deinit()

    try testing::expect(str.>length() == 13)
    try testing::expect(str.size == 13)

    .ok
}

test "length.unicode" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello, ðŸŒ!") catch {return .err}
    defer str.>deinit()

    try testing::expect(str.>length() == 9)
    try testing::expect(str.size == 12)

    .ok
}

test "find" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("ðŸ‘‹ Hello, ðŸŒ World!") catch {return .err}
    defer str.>deinit()

    try testing::expect(str.>find("ðŸ‘‹").some == 0)
    try testing::expect(str.>find("Hello").some == 2)
    try testing::expect(str.>find("ðŸŒ World!").some == 9)

    .ok
}

test "clone" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello, World!") catch {return .err}
    defer str.>deinit()
    
    let mut cloned_str = str.>clone() catch {return .err}
    defer cloned_str.>deinit()

    try testing::expect(cloned_str.>cmp(str.>str()))

    .ok
}

test "is_empty" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello, World!") catch {return .err}
    defer str.>deinit()

    try testing::expect(not str.>is_empty())

    .ok
}

test "concat" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello") catch {return .err}
    defer str.>deinit()

    str.>concat(", World!") catch {return .err}

    try testing::expect(str.>cmp("Hello, World!"))

    .ok
}

test "insert" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello World!") catch {return .err}
    defer str.>deinit()

    str.>insert(",", 5) catch {return .err}
    try testing::expect(str.>cmp("Hello, World!"))

    str.>insert("ðŸ‘‹", 5) catch {return .err}
    try testing::expect(str.>cmp("HelloðŸ‘‹, World!"))

    str.>insert("ðŸŒŽ", 13) catch {return .err}
    try testing::expect(str.>cmp("HelloðŸ‘‹, WorldðŸŒŽ!"))

    .ok
}

test "remove" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello, World!") catch {return .err}
    defer str.>deinit()

    str.>remove(5) catch {return .err}

    try testing::expect(str.>cmp("Hello World!"))

    .ok
}

test "remove_range" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello, ðŸŒ!") catch {return .err}
    defer str.>deinit()

    str.>remove_range(5, 8) catch {return .err}

    try testing::expect(str.>cmp("Hello!"))

    .ok
}

test "clear" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello, World!") catch {return .err}
    defer str.>deinit()

    str.>clear()

    try testing::expect(str.>length() == 0)
    try testing::expect(str.size == 0)

    .ok
}

test "to_lowercase" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("HELLO, WORLD ðŸŒŽ!") catch {return .err}
    defer str.>deinit()

    str.>to_lowercase()

    try testing::expect(str.>cmp("hello, world ðŸŒŽ!"))

    .ok
}

test "to_uppercase" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello, World ðŸŒŽ!") catch {return .err}
    defer str.>deinit()

    str.>to_uppercase()

    try testing::expect(str.>cmp("HELLO, WORLD ðŸŒŽ!"))

    .ok
}

test "replace" with core::Allocating {
    let mut str = String_Buffer::init_with_contents("Hello, World ðŸŒŽ!") catch {return .err}
    defer str.>deinit()

    let mut replaced = str.>replace("Hello", "Hi") catch {return .err}

    try testing::expect(str.>cmp("Hi, World ðŸŒŽ!"))
    try testing::expect(replaced)

    .ok
}

// Returns the real index of a unicode string literal
fn get_index(unicode: String, index: Int, real: Bool) -> ?Int {
    let mut i = 0
    let mut j = 0
    while i < unicode.length {
        if real {
            if j == index {return .some(i)}
        } else {
            if i == index {return .some(j)}
        }
        i += utf8_byte_sequence_length(unicode[i])
        j += 1
    }

    .none
}

// Returns the total length in bytes of a codepoint, given the first byte
fn utf8_byte_sequence_length(first_byte: Byte) -> Int {
    if first_byte >= 0 and first_byte <= 0b0111_1111 {
        1
    } else if first_byte >= 0b1100_0000 and first_byte <= 0b1101_1111 {
        2
    } else if first_byte >= 0b1110_0000 and first_byte <= 0b1110_1111 {
        3
    } else if first_byte >= 0b1111_0000 and first_byte <= 0b1111_0111 {
        4
    } else {
        1
    }
}