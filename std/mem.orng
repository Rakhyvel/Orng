import ffi

struct Heap_Allocator {}
impl core::Allocator for Heap_Allocator {
    virtual fn alloc(&mut self, nbytes: Int) -> ?[*mut]Byte {
        _ = self
        extern const malloc: Int -> [*mut]Byte
        .some(malloc(nbytes))
    }

    virtual fn free(&mut self, allocation: [*]Byte) {
        _ = self
        extern("free") const c_free: [*]Byte -> ()
        c_free(allocation)
    }

    virtual fn resize(&mut self, allocation: [*mut]Byte, newsize: Int) -> ?[*mut]Byte {
        _ = (self, allocation, newsize)
        unreachable
    }
}

fn new[T](alloc: &mut dyn core::Allocator) -> ()!&mut T {
    match alloc.>alloc(@sizeof(T)) {
        .some(bytes) => ffi::ref_from_ptr_mut[T](bytes as [*mut]T)
        .none => .err
    }
}

fn make[T](length: Int) -> ()![mut]T with core::Allocating {
    match core::Allocating.alloc.>alloc(@sizeof(T) * length) {
        .some(bytes) => {
            let mut retval: [mut]T = undefined
            retval.data = bytes as [*mut]T
            retval.length = length
            .ok(retval)
        }
        .none => .err
    }
}