import ffi

struct Heap_Allocator {}
impl core::Allocator for Heap_Allocator {
    virtual fn alloc(&mut self, nbytes: Int) -> ?[*mut]Byte {
        _ = self
        extern const malloc: Int -> [*mut]Byte
        .some(malloc(nbytes))
    }

    virtual fn realloc(&mut self, allocation: [*mut]Byte, newsize: Int) -> ?[*mut]Byte {
        _ = (self, allocation, newsize)
        unreachable
    }

    virtual fn free(&mut self, allocation: [*]Byte) {
        _ = self
        extern("free") const c_free: [*]Byte -> ()
        c_free(allocation)
    }
}

fn new[T](alloc: &mut dyn core::Allocator) -> ()!&mut T {
    match alloc.>alloc(@sizeof(T)) {
        .some(bytes) => ffi::ref_from_ptr_mut[T](bytes as [*mut]T)
        .none => .err
    }
}

fn make[T](length: Int) -> ()![mut]T with core::Allocating {
    match core::Allocating.alloc.>alloc(@sizeof(T) * length) {
        .some(bytes) => {
            let mut retval: [mut]T = undefined
            retval.data = bytes as [*mut]T
            retval.length = length
            .ok(retval)
        }
        .none => .err
    }
}

fn slice_from_parts[T](data: [*mut ]T, length: Int) -> [mut]T {
    let mut retval: [mut]T = undefined
    retval.data = data
    retval.length = length
    retval
}

fn eql(a: String, b: String) -> Bool {
    if a.length != b.length {return false}

    while let mut i = 0; i < a.length; i += 1 {
        if a[i] != b[i] {return false}
    }

    true
}

fn copy(dest: [mut]Byte, src: []Byte) {
    while let mut i = 0; i < src.length; i += 1 {
        dest[i] = src[i]
    }
}

fn index_of(haystack: []Byte, needle: []Byte) -> ?Int {
    if needle.length == 0 {
        return .some(0)
    }

    if needle.length > haystack.length {
        return .none
    }

    while let mut i = 0; i <= haystack.length - needle.length; i += 1 {
        let mut found = true

        while let mut j = 0; j < needle.length; j += 1 {
            if haystack[i + j] != needle[j] {
                found = false
                break
            }
        }

        if found {
            return .some(i)
        }
    }

    .none
}