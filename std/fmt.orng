import math
import mem
import string_buffer::String_Buffer
import testing

impl core::Format for Bool {
    virtual fn format(&self, writer: &mut dyn core::Writer) -> ()!() {
        if self^ {
            writer.>write("true")
        } else {
            writer.>write("false")
        }
    }
}

impl core::Format for Int {
    virtual fn format(&self, writer: &mut dyn core::Writer) -> ()!() {
        let mut value = self^
        let mut buf: [20]Byte // large enough for 64-bit int and sign
        let mut i = 0

        if value == 0 {
            try writer.>write("0")
            return .ok
        }

        // Handle sign
        if value < 0 {
            try writer.>write("-")
            value = -value
        }

        // Extract digits in reverse order
        while value > 0 {
            let digit = (value % 10) as Byte
            buf[i] = '0' + digit
            i += 1
            value /= 10
        }

        // Write digits in correct order
        let mut buf_slice = [mut]buf
        buf_slice.length = i
        mem::reverse(buf_slice)
        writer.>write(buf_slice)
    }
}

impl core::Format for Float {
    virtual fn format(&self, writer: &mut dyn core::Writer) -> ()!() {
        let mut value = self^

        // special cases
        if value.>is_nan() {
            try writer.>write("nan")
            return .ok
        } else if value.>is_inf() {
            if value < 0.0 {
                try writer.>write("-inf")
            } else {
                try writer.>write("inf")
            }
            return .ok
        }

        // handle sign
        if value < 0.0 {
            try writer.>write("-")
            value = -value
        }

        let int_part = math::truncate(value)
        let frac_part = value - math::as_float(int_part)

        try int_part.>format(writer)

        try writer.>write(".")

        const precision = 6
        let mut buf: [comptime{precision}]Byte
        let mut buf_slice = [mut]buf
        buf_slice.length = 0
        let mut scaled = frac_part
        while let mut i = 0; i < precision; i += 1 {
            scaled *= 10.0
            let digit = math::truncate(scaled)
            buf[i] = ('0' + digit) as Byte
            if digit != 0 {
                buf_slice.length = i + 1
            }
            scaled -= math::as_float(digit)
        }
        writer.>write(buf_slice)
    }
}

test "bool" with core::Allocating {
    let mut str = String_Buffer::init()
    defer str.>deinit()

    try true.>format(&mut str)
    try str.>write(" ")
    try false.>format(&mut str)

    try testing::expect(str.>cmp("true false"))

    .ok
}

test "string" with core::Allocating {
    let mut str = String_Buffer::init()
    defer str.>deinit()

    let hello = "Hello"
    let world = "World"

    try hello.>format(&mut str)
    try str.>write(", ")
    try world.>format(&mut str)
    try str.>write("!")

    try testing::expect(str.>cmp("Hello, World!"))

    .ok
}

test "int" with core::Allocating {
    let mut str = String_Buffer::init()
    defer str.>deinit()

    let x = 123456789
    let y = -100
    let z = 0

    try x.>format(&mut str)
    try str.>write(" ")
    try y.>format(&mut str)
    try str.>write(" ")
    try z.>format(&mut str)

    try testing::expect(str.>cmp("123456789 -100 0"))

    .ok
}

test "float" with core::Allocating {

    let mut str = String_Buffer::init()
    defer str.>deinit()

    let x = 3.14
    let y = -3.14
    let z = 1.0 / 0.0
    let a = -1.0 / 0.0
    let b = 0.0 / 0.0

    try x.>format(&mut str)
    try str.>write(" ")
    try y.>format(&mut str)
    try str.>write(" ")
    try z.>format(&mut str)
    try str.>write(" ")
    try a.>format(&mut str)
    try str.>write(" ")
    try b.>format(&mut str)

    try testing::expect(str.>cmp("3.14 -3.14 inf -inf nan"))

    .ok
}