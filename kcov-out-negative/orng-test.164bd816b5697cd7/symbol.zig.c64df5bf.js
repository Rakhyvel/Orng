var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std\");"},
{"lineNum":"    2","line":"const ast_ = @import(\"../ast/ast.zig\");"},
{"lineNum":"    3","line":"const CFG = @import(\"../ir/cfg.zig\");"},
{"lineNum":"    4","line":"const errs_ = @import(\"../util/errors.zig\");"},
{"lineNum":"    5","line":"const fmt_ = @import(\"../util/fmt.zig\");"},
{"lineNum":"    6","line":"const Scope = @import(\"../symbol/scope.zig\");"},
{"lineNum":"    7","line":"const Span = @import(\"../util/span.zig\");"},
{"lineNum":"    8","line":"const Token = @import(\"../lexer/token.zig\");"},
{"lineNum":"    9","line":"const Tree_Writer = @import(\"../ast/tree_writer.zig\");"},
{"lineNum":"   10","line":"const Type_AST = @import(\"../types/type.zig\").Type_AST;"},
{"lineNum":"   11","line":"const Monomorph_Map = @import(\"../ast/type_map.zig\").Monomorph_Map;"},
{"lineNum":"   12","line":"const unification_ = @import(\"../types/unification.zig\");"},
{"lineNum":"   13","line":"const validation_state_ = @import(\"../util/validation_state.zig\");"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"const Self = @This();"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"pub const Kind = union(enum) {"},
{"lineNum":"   18","line":"    @\"fn\","},
{"lineNum":"   19","line":"    @\"const\","},
{"lineNum":"   20","line":"    @\"comptime\","},
{"lineNum":"   21","line":"    let,"},
{"lineNum":"   22","line":"    mut,"},
{"lineNum":"   23","line":"    type,"},
{"lineNum":"   24","line":"    trait,"},
{"lineNum":"   25","line":"    import: struct { // Refers indirectly to modules, or to refinements on modules."},
{"lineNum":"   26","line":"        // Real name of the module, as oposed to the `as` name"},
{"lineNum":"   27","line":"        real_name: []const u8,"},
{"lineNum":"   28","line":"        real_symbol: ?*Self = null,"},
{"lineNum":"   29","line":"    },"},
{"lineNum":"   30","line":"    import_inner, // Created from the inner expressions of qualified import statements, similar to consts"},
{"lineNum":"   31","line":"    module, // Refers to modules. The init is the `module` AST, which refers to the module and to the scope. `Module`s have their symbol"},
{"lineNum":"   32","line":"    @\"test\","},
{"lineNum":"   33","line":"    context,"},
{"lineNum":"   34","line":"};"},
{"lineNum":"   35","line":""},
{"lineNum":"   36","line":"pub const Storage = union(enum) {"},
{"lineNum":"   37","line":"    local,"},
{"lineNum":"   38","line":"    @\"extern\": struct { c_name: ?*ast_.AST },"},
{"lineNum":"   39","line":"};"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"pub const Symbol_Validation_State = validation_state_.Validation_State;"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"scope: *Scope, // Enclosing parent scope"},
{"lineNum":"   44","line":"name: []const u8,"},
{"lineNum":"   45","line":"kind: Kind,"},
{"lineNum":"   46","line":"cfg: ?*CFG,"},
{"lineNum":"   47","line":"decl: ?*ast_.AST,"},
{"lineNum":"   48","line":"storage: Storage,"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"monomorphs: Monomorph_Map(*Self),"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"// Use-def"},
{"lineNum":"   53","line":"aliases: u64 = 0, // How many times the symbol is taken as a mutable address"},
{"lineNum":"   54","line":"roots: u64 = 0, // How many times the symbol is the root of an lvaue tree"},
{"lineNum":"   55","line":"uses: u64 = 0,"},
{"lineNum":"   56","line":"defs: u64 = 0,"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"defined: bool, // Used for decorating identifiers. True when the symbol is defined at the identifier"},
{"lineNum":"   59","line":"validation_state: Symbol_Validation_State,"},
{"lineNum":"   60","line":"init_validation_state: Symbol_Validation_State,"},
{"lineNum":"   61","line":"param: bool, // True when the symbol is a parameter in a function"},
{"lineNum":"   62","line":"is_temp: bool = false, // Whether this symbol is a temporary when lowered"},
{"lineNum":"   63","line":"is_monomorphed: bool = false, // Whether this symbol came from monomorphing a generic"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"// Offset"},
{"lineNum":"   66","line":"offset: ?i64, // The offset from the BP that this symbol, for local variables and parameters"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"pub fn init("},
{"lineNum":"   69","line":"    scope: *Scope,"},
{"lineNum":"   70","line":"    name: []const u8,"},
{"lineNum":"   71","line":"    decl: ?*ast_.AST,"},
{"lineNum":"   72","line":"    kind: Kind,"},
{"lineNum":"   73","line":"    storage: Storage,"},
{"lineNum":"   74","line":"    allocator: std.mem.Allocator,"},
{"lineNum":"   75","line":") *Self {","class":"lineCov","hits":"2","order":"240","possible_hits":"2",},
{"lineNum":"   76","line":"    var retval = allocator.create(Self) catch unreachable;","class":"lineCov","hits":"2","order":"241","possible_hits":"2",},
{"lineNum":"   77","line":"    retval.scope = scope;","class":"lineCov","hits":"1","order":"242","possible_hits":"1",},
{"lineNum":"   78","line":"    retval.name = name;","class":"lineCov","hits":"1","order":"243","possible_hits":"1",},
{"lineNum":"   79","line":"    retval.decl = decl;","class":"lineCov","hits":"1","order":"244","possible_hits":"1",},
{"lineNum":"   80","line":"    retval.aliases = 0;","class":"lineCov","hits":"1","order":"245","possible_hits":"1",},
{"lineNum":"   81","line":"    retval.roots = 0;","class":"lineCov","hits":"1","order":"246","possible_hits":"1",},
{"lineNum":"   82","line":"    retval.uses = 0;","class":"lineCov","hits":"1","order":"247","possible_hits":"1",},
{"lineNum":"   83","line":"    retval.offset = null;","class":"lineCov","hits":"1","order":"248","possible_hits":"1",},
{"lineNum":"   84","line":"    retval.kind = kind;","class":"lineCov","hits":"1","order":"249","possible_hits":"1",},
{"lineNum":"   85","line":"    retval.storage = storage;","class":"lineCov","hits":"1","order":"250","possible_hits":"1",},
{"lineNum":"   86","line":"    retval.monomorphs = Monomorph_Map(*Self).init(allocator);","class":"lineCov","hits":"1","order":"251","possible_hits":"1",},
{"lineNum":"   87","line":"    retval.cfg = null;","class":"lineCov","hits":"1","order":"255","possible_hits":"1",},
{"lineNum":"   88","line":"    if (kind == .@\"fn\" or kind == .@\"const\") {","class":"lineCov","hits":"2","order":"256","possible_hits":"2",},
{"lineNum":"   89","line":"        retval.defined = true;","class":"lineCov","hits":"1","order":"257","possible_hits":"1",},
{"lineNum":"   90","line":"    } else {"},
{"lineNum":"   91","line":"        retval.defined = false;","class":"lineCov","hits":"1","order":"309","possible_hits":"1",},
{"lineNum":"   92","line":"    }"},
{"lineNum":"   93","line":"    retval.validation_state = .unvalidated;","class":"lineCov","hits":"1","order":"258","possible_hits":"1",},
{"lineNum":"   94","line":"    retval.init_validation_state = .unvalidated;","class":"lineCov","hits":"1","order":"259","possible_hits":"1",},
{"lineNum":"   95","line":"    return retval;","class":"lineCov","hits":"1","order":"260","possible_hits":"1",},
{"lineNum":"   96","line":"}"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"pub fn assert_symbol_valid(self: *Self) *Self {","class":"lineCov","hits":"2","order":"262","possible_hits":"2",},
{"lineNum":"   99","line":"    self.validation_state = .valid;","class":"lineCov","hits":"1","order":"263","possible_hits":"1",},
{"lineNum":"  100","line":"    return self;","class":"lineCov","hits":"1","order":"264","possible_hits":"1",},
{"lineNum":"  101","line":"}"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"pub fn assert_init_valid(self: *Self) *Self {","class":"lineCov","hits":"2","order":"2218","possible_hits":"2",},
{"lineNum":"  104","line":"    self.init_validation_state = .valid;","class":"lineCov","hits":"1","order":"2219","possible_hits":"1",},
{"lineNum":"  105","line":"    return self;","class":"lineCov","hits":"1","order":"2220","possible_hits":"1",},
{"lineNum":"  106","line":"}"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"/// Whether or not this symbol represents a type or not"},
{"lineNum":"  109","line":"pub fn is_type(self: *const Self) bool {","class":"lineCov","hits":"2","order":"1978","possible_hits":"2",},
{"lineNum":"  110","line":"    return self.decl.?.* == .struct_decl or self.decl.?.* == .enum_decl or self.decl.?.* == .type_alias or self.decl.?.* == .type_param_decl;","class":"lineCov","hits":"1","order":"1979","possible_hits":"1",},
{"lineNum":"  111","line":"}"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"pub fn @\"type\"(self: *const Self) *Type_AST {","class":"lineCov","hits":"2","order":"2222","possible_hits":"2",},
{"lineNum":"  114","line":"    return self.decl.?.decl_type();","class":"lineCov","hits":"1","order":"2223","possible_hits":"1",},
{"lineNum":"  115","line":"}"},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"pub fn init_value(self: *const Self) ?*ast_.AST {","class":"lineCov","hits":"2","order":"2058","possible_hits":"2",},
{"lineNum":"  118","line":"    return self.decl.?.decl_init();","class":"lineCov","hits":"1","order":"2059","possible_hits":"1",},
{"lineNum":"  119","line":"}"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"pub fn init_typedef(self: *const Self) ?*Type_AST {","class":"lineCov","hits":"2","order":"2076","possible_hits":"2",},
{"lineNum":"  122","line":"    return self.decl.?.decl_typedef();","class":"lineCov","hits":"1","order":"2077","possible_hits":"1",},
{"lineNum":"  123","line":"}"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"pub fn span(self: *const Self) Span {","class":"lineCov","hits":"2","order":"2583","possible_hits":"2",},
{"lineNum":"  126","line":"    return self.decl.?.token().span;","class":"lineCov","hits":"1","order":"2584","possible_hits":"1",},
{"lineNum":"  127","line":"}"},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"pub fn set_span(self: *Self, _span: Span) void {","class":"lineCov","hits":"2","order":"4538","possible_hits":"2",},
{"lineNum":"  130","line":"    self.decl.?.common()._token.span = _span;","class":"lineCov","hits":"1","order":"4539","possible_hits":"1",},
{"lineNum":"  131","line":"}"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"pub fn expanded_type(self: *const Self) *Type_AST {","class":"lineCov","hits":"2","order":"2785","possible_hits":"2",},
{"lineNum":"  134","line":"    return self.type().expand_identifier();","class":"lineCov","hits":"1","order":"2786","possible_hits":"1",},
{"lineNum":"  135","line":"}"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"/// when this is true, this symbol is a type-alias, and should be expanded before use"},
{"lineNum":"  138","line":"pub fn is_alias(self: *Self) bool {","class":"lineCov","hits":"2","order":"2120","possible_hits":"2",},
{"lineNum":"  139","line":"    if (self.decl != null and self.decl.?.* == .type_alias) return true;","class":"lineCov","hits":"2","order":"2121","possible_hits":"2",},
{"lineNum":"  140","line":"    return false;","class":"lineCov","hits":"1","order":"2383","possible_hits":"1",},
{"lineNum":"  141","line":"}"},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"pub fn lvalue_is_symbol(self: *Self, return_symbol: *Self) bool {","class":"lineCov","hits":"2","order":"2737","possible_hits":"2",},
{"lineNum":"  144","line":"    return !self.is_temp and // isnt temporary","class":"lineCov","hits":"1","order":"2738","possible_hits":"1",},
{"lineNum":"  145","line":"        self != return_symbol // isnt the function\'s return value"},
{"lineNum":"  146","line":"    ;"},
{"lineNum":"  147","line":"}"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"pub fn err_if_undefined(self: *Self, errors: *errs_.Errors) error{CompileError}!void {"},
{"lineNum":"  150","line":"    if (self.kind != .import and !self.defined) {"},
{"lineNum":"  151","line":"        errors.add_error(errs_.Error{ .use_before_def = .{ .identifier = Token.init_simple(self.name) } });"},
{"lineNum":"  152","line":"        return error.CompileError;"},
{"lineNum":"  153","line":"    }"},
{"lineNum":"  154","line":"}"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"/// Throws an `error.CompileError` if a symbol is not used."},
{"lineNum":"  157","line":"pub fn err_if_unused(self: *Self, errors: *errs_.Errors) error{CompileError}!void {","class":"lineCov","hits":"2","order":"3652","possible_hits":"2",},
{"lineNum":"  158","line":"    if (self.kind != .@\"const\" and self.uses == 0) {","class":"lineCov","hits":"2","order":"3653","possible_hits":"2",},
{"lineNum":"  159","line":"        // TODO: Add a better error for contexts, say `context My_Context is unused` or something"},
{"lineNum":"  160","line":"        errors.add_error(errs_.Error{ .symbol_error = .{","class":"lineCov","hits":"2","order":"4746","possible_hits":"2",},
{"lineNum":"  161","line":"            .span = self.span(),","class":"lineCov","hits":"1","order":"4747","possible_hits":"1",},
{"lineNum":"  162","line":"            .context_span = null,"},
{"lineNum":"  163","line":"            .name = self.name,","class":"lineCov","hits":"1","order":"4748","possible_hits":"1",},
{"lineNum":"  164","line":"            .problem = \"is never used\","},
{"lineNum":"  165","line":"            .context_message = \"\","},
{"lineNum":"  166","line":"        } });"},
{"lineNum":"  167","line":"        return error.CompileError;","class":"lineCov","hits":"2","order":"3654","possible_hits":"2",},
{"lineNum":"  168","line":"    }"},
{"lineNum":"  169","line":"}"},
{"lineNum":"  170","line":""},
{"lineNum":"  171","line":"pub fn err_if_undefd(self: *Self, errors: *errs_.Errors, use: Span) error{CompileError}!void {","class":"lineCov","hits":"2","order":"3661","possible_hits":"2",},
{"lineNum":"  172","line":"    // std.debug.print(\"{s} uses:{} defs:{}\\n\", .{ self.name, self.uses, self.defs });"},
{"lineNum":"  173","line":"    if (self.uses != 0 and // symbol has been used somewhere","class":"lineCov","hits":"1","order":"3662","possible_hits":"1",},
{"lineNum":"  174","line":"        self.defs == 0 and // symbol hasn\'t been defined anywhere","class":"lineCov","hits":"1","order":"3663","possible_hits":"1",},
{"lineNum":"  175","line":"        !self.param and // symbol isn\'t a parameter (these don\'t have defs!)","class":"lineCov","hits":"1","order":"3664","possible_hits":"1",},
{"lineNum":"  176","line":"        self.storage != .@\"extern\" // symbol isn\'t an extern (these also don\'t have defs!)","class":"lineCov","hits":"1","order":"3665","possible_hits":"1",},
{"lineNum":"  177","line":"    ) {"},
{"lineNum":"  178","line":"        errors.add_error(errs_.Error{ .symbol_error = .{","class":"lineCov","hits":"2","order":"4958","possible_hits":"2",},
{"lineNum":"  179","line":"            .span = use,"},
{"lineNum":"  180","line":"            .context_span = self.span(),","class":"lineCov","hits":"1","order":"4959","possible_hits":"1",},
{"lineNum":"  181","line":"            .name = self.name,","class":"lineCov","hits":"1","order":"4960","possible_hits":"1",},
{"lineNum":"  182","line":"            .problem = \"is never defined\","},
{"lineNum":"  183","line":"            .context_message = \"declared here\","},
{"lineNum":"  184","line":"        } });"},
{"lineNum":"  185","line":"        return error.CompileError;","class":"lineCov","hits":"2","order":"3666","possible_hits":"2",},
{"lineNum":"  186","line":"    }"},
{"lineNum":"  187","line":"}"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"/// Throws an `error.CompileError` if a symbol is marked `mut`, but is never mutated."},
{"lineNum":"  190","line":"///"},
{"lineNum":"  191","line":"/// Symbols are mutated when:"},
{"lineNum":"  192","line":"/// - They are the root of at least one Instruction\'s destination\'s L-Value tree, OR"},
{"lineNum":"  193","line":"/// - They are aliased with `&mut`."},
{"lineNum":"  194","line":"pub fn err_if_var_not_mutated(self: *Self, errors: *errs_.Errors) error{CompileError}!void {","class":"lineCov","hits":"2","order":"3656","possible_hits":"2",},
{"lineNum":"  195","line":"    if (self.kind == .mut and","class":"lineCov","hits":"1","order":"3657","possible_hits":"1",},
{"lineNum":"  196","line":"        self.aliases == 0 and","class":"lineCov","hits":"3","order":"3658","possible_hits":"3",},
{"lineNum":"  197","line":"        self.roots == 0)","class":"lineCov","hits":"3","order":"3659","possible_hits":"3",},
{"lineNum":"  198","line":"    {"},
{"lineNum":"  199","line":"        errors.add_error(errs_.Error{ .symbol_error = .{","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  200","line":"            .span = self.span(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  201","line":"            .context_span = null,"},
{"lineNum":"  202","line":"            .name = self.name,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  203","line":"            .problem = \"is marked `mut` but is never mutated\","},
{"lineNum":"  204","line":"            .context_message = \"\","},
{"lineNum":"  205","line":"        } });"},
{"lineNum":"  206","line":"        return error.CompileError;","class":"linePartCov","hits":"1","order":"3660","possible_hits":"2",},
{"lineNum":"  207","line":"    }"},
{"lineNum":"  208","line":"}"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"pub fn set_offset(self: *Self, local_offsets: i64) i64 {","class":"lineCov","hits":"2","order":"3038","possible_hits":"2",},
{"lineNum":"  211","line":"    self.offset = local_offsets;","class":"lineCov","hits":"1","order":"3039","possible_hits":"1",},
{"lineNum":"  212","line":"    return @as(i64, @intCast(self.expanded_type().sizeof()));","class":"lineCov","hits":"1","order":"3040","possible_hits":"1",},
{"lineNum":"  213","line":"}"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"pub fn represents_method(self: *Self, impl_for_type: *Type_AST, method_name: []const u8) bool {","class":"lineCov","hits":"2","order":"4583","possible_hits":"2",},
{"lineNum":"  216","line":"    return self.decl != null and","class":"lineCov","hits":"2","order":"4584","possible_hits":"2",},
{"lineNum":"  217","line":"        self.decl.?.* == .method_decl and","class":"linePartCov","hits":"2","order":"4585","possible_hits":"3",},
{"lineNum":"  218","line":"        self.decl.?.method_decl.impl != null and","class":"linePartCov","hits":"2","order":"4586","possible_hits":"3",},
{"lineNum":"  219","line":"        self.decl.?.method_decl.impl.?.impl._type.types_match(impl_for_type) and","class":"linePartCov","hits":"2","order":"4587","possible_hits":"3",},
{"lineNum":"  220","line":"        std.mem.eql(u8, self.name, method_name);","class":"linePartCov","hits":"1","order":"4588","possible_hits":"2",},
{"lineNum":"  221","line":"}"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"var num_anons: usize = 0;"},
{"lineNum":"  224","line":"fn next_anon_name(class: []const u8, allocator: std.mem.Allocator) []const u8 {","class":"lineCov","hits":"2","order":"5304","possible_hits":"2",},
{"lineNum":"  225","line":"    defer num_anons += 1;","class":"linePartCov","hits":"1","order":"5309","possible_hits":"2",},
{"lineNum":"  226","line":"    var out = std.array_list.Managed(u8).init(allocator);","class":"lineCov","hits":"1","order":"5305","possible_hits":"1",},
{"lineNum":"  227","line":"    defer out.deinit();","class":"lineCov","hits":"1","order":"5308","possible_hits":"1",},
{"lineNum":"  228","line":"    out.print(\"{s}__{}\", .{ class, num_anons }) catch unreachable;","class":"lineCov","hits":"2","order":"5306","possible_hits":"2",},
{"lineNum":"  229","line":"    return out.toOwnedSlice() catch unreachable;","class":"lineCov","hits":"3","order":"5307","possible_hits":"3",},
{"lineNum":"  230","line":"}"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"const Compiler_Context = @import(\"../hierarchy/compiler.zig\");"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"pub fn monomorphize("},
{"lineNum":"  235","line":"    self: *Self,"},
{"lineNum":"  236","line":"    key: std.array_list.Managed(*Type_AST),"},
{"lineNum":"  237","line":"    ctx: *Compiler_Context,"},
{"lineNum":"  238","line":") error{ OutOfMemory, CompileError }!*Self {","class":"lineCov","hits":"2","order":"5293","possible_hits":"2",},
{"lineNum":"  239","line":"    if (self.monomorphs.get(key)) |retval| {","class":"lineCov","hits":"1","order":"5294","possible_hits":"1",},
{"lineNum":"  240","line":"        return retval;","class":"lineCov","hits":"1","order":"5498","possible_hits":"1",},
{"lineNum":"  241","line":"    } else {"},
{"lineNum":"  242","line":"        // Create a substitution map that subs the param names for the given arg types"},
{"lineNum":"  243","line":"        var subst = unification_.Substitutions.init(ctx.allocator());","class":"lineCov","hits":"1","order":"5299","possible_hits":"1",},
{"lineNum":"  244","line":"        defer subst.deinit();","class":"linePartCov","hits":"1","order":"5351","possible_hits":"6",},
{"lineNum":"  245","line":"        for (self.decl.?.generic_params().items, key.items) |param, arg| {","class":"lineCov","hits":"3","order":"5300","possible_hits":"3",},
{"lineNum":"  246","line":"            try subst.put(param.token().data, arg);","class":"linePartCov","hits":"1","order":"5301","possible_hits":"2",},
{"lineNum":"  247","line":"        }","class":"lineCov","hits":"3","order":"5302","possible_hits":"3",},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"        // Clone the decl with the substitution"},
{"lineNum":"  250","line":"        const name = next_anon_name(self.name, ctx.allocator());","class":"lineCov","hits":"1","order":"5303","possible_hits":"1",},
{"lineNum":"  251","line":"        const decl = self.decl.?.clone(&subst, ctx.allocator());","class":"lineCov","hits":"3","order":"5310","possible_hits":"3",},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"        const Symbol_Tree = @import(\"../ast/symbol-tree.zig\");"},
{"lineNum":"  254","line":"        const Decorate = @import(\"../ast/decorate.zig\");"},
{"lineNum":"  255","line":"        const walker_ = @import(\"../ast/walker.zig\");"},
{"lineNum":"  256","line":""},
{"lineNum":"  257","line":"        var all_concrete: bool = true;","class":"lineCov","hits":"1","order":"5320","possible_hits":"1",},
{"lineNum":"  258","line":"        for (key.items) |k| {","class":"lineCov","hits":"3","order":"5321","possible_hits":"3",},
{"lineNum":"  259","line":"            if (k.* == .identifier and k.symbol().?.decl.?.* == .type_param_decl) {","class":"lineCov","hits":"2","order":"5322","possible_hits":"2",},
{"lineNum":"  260","line":"                all_concrete = false;","class":"lineCov","hits":"1","order":"5401","possible_hits":"1",},
{"lineNum":"  261","line":"            }"},
{"lineNum":"  262","line":"        }","class":"lineCov","hits":"2","order":"5323","possible_hits":"2",},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"        if (all_concrete) {","class":"lineCov","hits":"1","order":"5324","possible_hits":"1",},
{"lineNum":"  265","line":"            decl.set_generic_params(std.array_list.Managed(*ast_.AST).init(ctx.allocator()));","class":"lineCov","hits":"1","order":"5325","possible_hits":"1",},
{"lineNum":"  266","line":"        }"},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"        // Decorate identifiers, validate"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"        const scope = self.decl.?.scope().?.parent.?;","class":"lineCov","hits":"3","order":"5330","possible_hits":"3",},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"        const symbol_tree_context = Symbol_Tree.new(scope, &ctx.errors, ctx.allocator());","class":"lineCov","hits":"1","order":"5331","possible_hits":"1",},
{"lineNum":"  273","line":"        const decorate_context = Decorate.new(scope, ctx);","class":"lineCov","hits":"1","order":"5332","possible_hits":"1",},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"        decl.set_decl_name(ast_.AST.create_pattern_symbol(","class":"lineCov","hits":"2","order":"5333","possible_hits":"2",},
{"lineNum":"  276","line":"            Token.init_simple(name),","class":"lineCov","hits":"1","order":"5334","possible_hits":"1",},
{"lineNum":"  277","line":"            self.kind,","class":"lineCov","hits":"1","order":"5335","possible_hits":"1",},
{"lineNum":"  278","line":"            self.storage,","class":"lineCov","hits":"1","order":"5336","possible_hits":"1",},
{"lineNum":"  279","line":"            name,"},
{"lineNum":"  280","line":"            ctx.allocator(),","class":"lineCov","hits":"1","order":"5337","possible_hits":"1",},
{"lineNum":"  281","line":"        ));"},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"        try walker_.walk_ast(decl, symbol_tree_context);","class":"linePartCov","hits":"1","order":"5342","possible_hits":"2",},
{"lineNum":"  284","line":"        try walker_.walk_ast(decl, decorate_context);","class":"linePartCov","hits":"1","order":"5343","possible_hits":"2",},
{"lineNum":"  285","line":""},
{"lineNum":"  286","line":"        const clone = decl.symbol().?;","class":"lineCov","hits":"2","order":"5344","possible_hits":"2",},
{"lineNum":"  287","line":"        std.debug.assert(clone.cfg == null);","class":"lineCov","hits":"1","order":"5345","possible_hits":"1",},
{"lineNum":"  288","line":"        try self.monomorphs.put(try key.clone(), clone);","class":"linePartCov","hits":"1","order":"5346","possible_hits":"4",},
{"lineNum":"  289","line":"        clone.is_monomorphed = true;","class":"lineCov","hits":"1","order":"5350","possible_hits":"1",},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"        return clone;","class":"lineCov","hits":"1","order":"5352","possible_hits":"1",},
{"lineNum":"  292","line":"    }"},
{"lineNum":"  293","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "orng-test", "date" : "2025-11-10 15:43:08", "instrumented" : 114, "covered" : 111,};
var merged_data = [];
