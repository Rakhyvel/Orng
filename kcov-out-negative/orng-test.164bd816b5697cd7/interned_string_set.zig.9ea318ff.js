var data = {lines:[
{"lineNum":"    1","line":"///! Handles interned strings. These are required mainly for the interpreter, since strings conceptually are a slice"},
{"lineNum":"    2","line":"/// referring to some piece of backing data. The interned string set per module is where the backing text data is"},
{"lineNum":"    3","line":"/// stored."},
{"lineNum":"    4","line":"const std = @import(\"std\");"},
{"lineNum":"    5","line":""},
{"lineNum":"    6","line":"const Self: type = @This();"},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"pub const String_Idx: type = struct {"},
{"lineNum":"    9","line":"    module_uid: u32,"},
{"lineNum":"   10","line":"    string_idx: u32,"},
{"lineNum":"   11","line":"};"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"uid: u32,"},
{"lineNum":"   14","line":"interned_strings: std.array_list.Managed([]const u8),"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"pub fn init(uid: u32, allocator: std.mem.Allocator) Self {","class":"lineCov","hits":"2","order":"476","possible_hits":"2",},
{"lineNum":"   17","line":"    return Self{","class":"lineCov","hits":"1","order":"478","possible_hits":"1",},
{"lineNum":"   18","line":"        .uid = uid,"},
{"lineNum":"   19","line":"        .interned_strings = std.array_list.Managed([]const u8).init(allocator),","class":"lineCov","hits":"1","order":"477","possible_hits":"1",},
{"lineNum":"   20","line":"    };"},
{"lineNum":"   21","line":"}"},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"pub fn add_string(self: *Self, str: []const u8, uid: u32) String_Idx {","class":"lineCov","hits":"2","order":"3598","possible_hits":"2",},
{"lineNum":"   24","line":"    std.debug.assert(uid == self.uid);","class":"lineCov","hits":"1","order":"3599","possible_hits":"1",},
{"lineNum":"   25","line":"    for (0..self.interned_strings.items.len) |i| {","class":"lineCov","hits":"3","order":"3600","possible_hits":"3",},
{"lineNum":"   26","line":"        const item = self.interned_strings.items[i];","class":"lineCov","hits":"3","order":"3737","possible_hits":"3",},
{"lineNum":"   27","line":"        if (std.mem.eql(u8, item, str)) {","class":"lineCov","hits":"1","order":"3738","possible_hits":"1",},
{"lineNum":"   28","line":"            return .{ .module_uid = self.uid, .string_idx = @as(u32, @intCast(i)) };","class":"linePartCov","hits":"1","order":"3739","possible_hits":"2",},
{"lineNum":"   29","line":"        }"},
{"lineNum":"   30","line":"    }","class":"linePartCov","hits":"1","order":"3601","possible_hits":"3",},
{"lineNum":"   31","line":"    // sanitized_str must not be in set, add it"},
{"lineNum":"   32","line":"    const idx: u32 = @intCast(self.interned_strings.items.len);","class":"linePartCov","hits":"1","order":"3602","possible_hits":"2",},
{"lineNum":"   33","line":"    self.interned_strings.append(str) catch unreachable;","class":"lineCov","hits":"2","order":"3603","possible_hits":"2",},
{"lineNum":"   34","line":"    return .{ .module_uid = self.uid, .string_idx = idx };","class":"lineCov","hits":"1","order":"3604","possible_hits":"1",},
{"lineNum":"   35","line":"}"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"pub fn merge(self: *Self, other: *const Self) void {"},
{"lineNum":"   38","line":"    for (0..other.interned_strings.items) |i| {"},
{"lineNum":"   39","line":"        _ = self.add_string(other.interned_strings.items[i]);"},
{"lineNum":"   40","line":"    }"},
{"lineNum":"   41","line":"}"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"pub fn items(self: *const Self) []const []const u8 {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   44","line":"    return self.interned_strings.items;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   45","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "orng-test", "date" : "2025-11-10 15:43:08", "instrumented" : 15, "covered" : 13,};
var merged_data = [];
