var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std\");"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"pub fn Dfs_Iterator(comptime T: type) type {"},
{"lineNum":"    4","line":"    return struct {"},
{"lineNum":"    5","line":"        const Self = @This();"},
{"lineNum":"    6","line":"        current: ?T,"},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"        stack: std.array_list.Managed(T),"},
{"lineNum":"    9","line":"        visited: std.AutoHashMap(T, void),"},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"        pub fn init(start: T, allocator: std.mem.Allocator) Self {","class":"linePartCov","hits":"2","order":"3698","possible_hits":"5",},
{"lineNum":"   12","line":"            return Self{","class":"linePartCov","hits":"1","order":"3701","possible_hits":"3",},
{"lineNum":"   13","line":"                .current = start,"},
{"lineNum":"   14","line":"                .stack = std.array_list.Managed(T).init(allocator),","class":"linePartCov","hits":"1","order":"3699","possible_hits":"3",},
{"lineNum":"   15","line":"                .visited = std.AutoHashMap(T, void).init(allocator),","class":"linePartCov","hits":"1","order":"3700","possible_hits":"3",},
{"lineNum":"   16","line":"            };"},
{"lineNum":"   17","line":"        }"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"        pub fn deinit(self: *Self) void {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   20","line":"            self.stack.deinit();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   21","line":"            self.visited.deinit();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   22","line":"        }"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"        pub fn next(self: *Self) ?T {","class":"linePartCov","hits":"2","order":"3703","possible_hits":"6",},
{"lineNum":"   25","line":"            // If we\'re out of values, then we\'re done"},
{"lineNum":"   26","line":"            if (self.current == null) return null;","class":"linePartCov","hits":"2","order":"3704","possible_hits":"6",},
{"lineNum":"   27","line":""},
{"lineNum":"   28","line":"            // Our result is our current value"},
{"lineNum":"   29","line":"            const result = self.current orelse unreachable;","class":"linePartCov","hits":"3","order":"3705","possible_hits":"8",},
{"lineNum":"   30","line":"            self.visited.put(result, {}) catch unreachable;","class":"linePartCov","hits":"2","order":"3706","possible_hits":"6",},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"            // Add all adjacent edges to the stack."},
{"lineNum":"   33","line":"            // We do a visited check here to avoid revisiting vertices"},
{"lineNum":"   34","line":"            const adjacent: []T = self.current.?.get_adjacent();","class":"linePartCov","hits":"3","order":"3707","possible_hits":"9",},
{"lineNum":"   35","line":"            for (adjacent) |target| {","class":"linePartCov","hits":"2","order":"3710","possible_hits":"9",},
{"lineNum":"   36","line":"                if (!self.visited.contains(target)) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   37","line":"                    self.stack.append(target) catch unreachable;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   38","line":"                }"},
{"lineNum":"   39","line":"            }","class":"linePartCov","hits":"1","order":"3711","possible_hits":"8",},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"            // If the type allows us to free the adjacency slice, free it."},
{"lineNum":"   42","line":"            if (@typeInfo(T) == .@\"struct\" and @hasDecl(T, \"free_adjacent\")) {"},
{"lineNum":"   43","line":"                self.current.?.free_adjacent(adjacent);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   44","line":"                // Side note: this sucks! If only zig had traits!"},
{"lineNum":"   45","line":"            } else if (@typeInfo(T) == .pointer and @typeInfo(@typeInfo(T).pointer.child) == .@\"struct\" and @hasDecl(@typeInfo(T).pointer.child, \"free_adjacent\")) {"},
{"lineNum":"   46","line":"                self.current.?.free_adjacent(adjacent);"},
{"lineNum":"   47","line":"            }"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"            // Advance to the next value"},
{"lineNum":"   50","line":"            self.current = null;","class":"linePartCov","hits":"1","order":"3712","possible_hits":"3",},
{"lineNum":"   51","line":"            while (self.stack.pop()) |next_val| {","class":"linePartCov","hits":"1","order":"3713","possible_hits":"6",},
{"lineNum":"   52","line":"                if (!self.visited.contains(next_val)) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   53","line":"                    self.current = next_val;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   54","line":"                    break;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   55","line":"                }"},
{"lineNum":"   56","line":"            }","class":"linePartCov","hits":"1","order":"3714","possible_hits":"8",},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"            return result;","class":"linePartCov","hits":"1","order":"3715","possible_hits":"3",},
{"lineNum":"   59","line":"        }"},
{"lineNum":"   60","line":"    };"},
{"lineNum":"   61","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "orng-test", "date" : "2025-11-10 15:43:08", "instrumented" : 24, "covered" : 15,};
var merged_data = [];
