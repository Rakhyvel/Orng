var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std\");"},
{"lineNum":"    2","line":"const Type_AST = @import(\"../types/type.zig\").Type_AST;"},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"/// A type map using C type equivelence"},
{"lineNum":"    5","line":"pub fn C_Type_Map(comptime Value: type) type {"},
{"lineNum":"    6","line":"    return Linear_Map(*Type_AST, Value, Type_AST.c_types_match);"},
{"lineNum":"    7","line":"}"},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"/// A type map using an arraylist of types as a key"},
{"lineNum":"   10","line":"pub fn Monomorph_Map(comptime Value: type) type {"},
{"lineNum":"   11","line":"    return Linear_Map(std.array_list.Managed(*Type_AST), Value, type_lists_match);"},
{"lineNum":"   12","line":"}"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"/// TODO: This could be moved out to util"},
{"lineNum":"   15","line":"/// A map data structure that stores its key-value pairs linearly in an arraylist, with get and put operations"},
{"lineNum":"   16","line":"/// defined based on an equivalence function."},
{"lineNum":"   17","line":"pub fn Linear_Map(comptime Key: type, comptime Value: type, comptime eq: fn (Key, Key) bool) type {"},
{"lineNum":"   18","line":"    return struct {"},
{"lineNum":"   19","line":"        /// A key-value pair"},
{"lineNum":"   20","line":"        const Pair = struct {"},
{"lineNum":"   21","line":"            key: Key,"},
{"lineNum":"   22","line":"            value: Value,"},
{"lineNum":"   23","line":"        };"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"        const Self = @This();"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"        /// List of pairs of the map"},
{"lineNum":"   28","line":"        pairs: std.array_list.Managed(Pair),"},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"        /// Initialize the map with an allocator"},
{"lineNum":"   31","line":"        pub fn init(alloc: std.mem.Allocator) Self {","class":"linePartCov","hits":"2","order":"252","possible_hits":"3",},
{"lineNum":"   32","line":"            return .{","class":"linePartCov","hits":"2","order":"254","possible_hits":"3",},
{"lineNum":"   33","line":"                .pairs = std.array_list.Managed(Pair).init(alloc),","class":"linePartCov","hits":"2","order":"253","possible_hits":"3",},
{"lineNum":"   34","line":"            };"},
{"lineNum":"   35","line":"        }"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"        /// Deinitializes the map"},
{"lineNum":"   38","line":"        pub fn deinit(self: *Self) void {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   39","line":"            self.pairs.deinit();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   40","line":"        }"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"        /// Returns the value corresponding to the given key, or null"},
{"lineNum":"   43","line":"        pub fn get(self: *const Self, key: Key) ?Value {","class":"linePartCov","hits":"4","order":"5295","possible_hits":"6",},
{"lineNum":"   44","line":"            for (self.pairs.items) |pair| {","class":"linePartCov","hits":"6","order":"5296","possible_hits":"9",},
{"lineNum":"   45","line":"                if (eq(pair.key, key)) {","class":"linePartCov","hits":"2","order":"5394","possible_hits":"3",},
{"lineNum":"   46","line":"                    return pair.value;","class":"linePartCov","hits":"2","order":"5497","possible_hits":"3",},
{"lineNum":"   47","line":"                }"},
{"lineNum":"   48","line":"            }","class":"linePartCov","hits":"3","order":"5297","possible_hits":"7",},
{"lineNum":"   49","line":"            return null;","class":"linePartCov","hits":"2","order":"5298","possible_hits":"3",},
{"lineNum":"   50","line":"        }"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"        /// Determines if the map contains the given key"},
{"lineNum":"   53","line":"        pub fn contains(self: *const Self, key: Key) bool {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   54","line":"            return self.get(key) != null;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   55","line":"        }"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"        /// Adds the key value pair if the map does not contain the key, does nothing if the map does contain the key"},
{"lineNum":"   58","line":"        pub fn put(self: *Self, key: Key, value: Value) !void {","class":"linePartCov","hits":"4","order":"5347","possible_hits":"6",},
{"lineNum":"   59","line":"            if (self.get(key)) |_| {","class":"linePartCov","hits":"2","order":"5348","possible_hits":"3",},
{"lineNum":"   60","line":"                return;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   61","line":"            }"},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"            try self.pairs.append(.{ .key = key, .value = value });","class":"linePartCov","hits":"2","order":"5349","possible_hits":"6",},
{"lineNum":"   64","line":"        }"},
{"lineNum":"   65","line":"    };"},
{"lineNum":"   66","line":"}"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"pub fn type_lists_match(lhs: std.array_list.Managed(*Type_AST), rhs: std.array_list.Managed(*Type_AST)) bool {","class":"lineCov","hits":"1","order":"5395","possible_hits":"1",},
{"lineNum":"   69","line":"    if (lhs.items.len != rhs.items.len) {","class":"lineCov","hits":"1","order":"5396","possible_hits":"1",},
{"lineNum":"   70","line":"        return false;","class":"linePartCov","hits":"1","order":"5397","possible_hits":"2",},
{"lineNum":"   71","line":"    }"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"    for (lhs.items, rhs.items) |lhs_item, rhs_item| {","class":"lineCov","hits":"4","order":"5398","possible_hits":"4",},
{"lineNum":"   74","line":"        if (!lhs_item.types_match(rhs_item) or !rhs_item.types_match(lhs_item)) {","class":"lineCov","hits":"2","order":"5399","possible_hits":"2",},
{"lineNum":"   75","line":"            return false;","class":"lineCov","hits":"1","order":"5400","possible_hits":"1",},
{"lineNum":"   76","line":"        }"},
{"lineNum":"   77","line":"    }","class":"lineCov","hits":"2","order":"5495","possible_hits":"2",},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"    return true;","class":"lineCov","hits":"1","order":"5496","possible_hits":"1",},
{"lineNum":"   80","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "orng-test", "date" : "2025-11-10 15:43:08", "instrumented" : 25, "covered" : 20,};
var merged_data = [];
