var data = {lines:[
{"lineNum":"    1","line":"//! This file represents a struct for an AST walk, and expands complex import pattern ASTs into simpler forms which"},
{"lineNum":"    2","line":"//! are easier to work with."},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"const std = @import(\"std\");"},
{"lineNum":"    5","line":"const ast_ = @import(\"../ast/ast.zig\");"},
{"lineNum":"    6","line":"const Compiler_Context = @import(\"../hierarchy/compiler.zig\");"},
{"lineNum":"    7","line":"const Module = @import(\"../hierarchy/module.zig\").Module;"},
{"lineNum":"    8","line":"const prelude_ = @import(\"../hierarchy/prelude.zig\");"},
{"lineNum":"    9","line":"const Symbol = @import(\"../symbol/symbol.zig\");"},
{"lineNum":"   10","line":"const Token = @import(\"../lexer/token.zig\");"},
{"lineNum":"   11","line":"const Type_AST = @import(\"../types/type.zig\").Type_AST;"},
{"lineNum":"   12","line":"const walker_ = @import(\"../ast/walker.zig\");"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"package_absolute_path: []const u8,"},
{"lineNum":"   15","line":"local_imported_modules: *std.AutoArrayHashMap(*Module, void),"},
{"lineNum":"   16","line":"compiler: *Compiler_Context,"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"const Self = @This();"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"pub fn new("},
{"lineNum":"   21","line":"    compiler: *Compiler_Context,"},
{"lineNum":"   22","line":"    package_absolute_path: []const u8,"},
{"lineNum":"   23","line":"    local_imported_modules: *std.AutoArrayHashMap(*Module, void),"},
{"lineNum":"   24","line":") Self {","class":"lineCov","hits":"2","order":"511","possible_hits":"2",},
{"lineNum":"   25","line":"    return Self{","class":"lineCov","hits":"1","order":"512","possible_hits":"1",},
{"lineNum":"   26","line":"        .compiler = compiler,"},
{"lineNum":"   27","line":"        .package_absolute_path = package_absolute_path,"},
{"lineNum":"   28","line":"        .local_imported_modules = local_imported_modules,"},
{"lineNum":"   29","line":"    };"},
{"lineNum":"   30","line":"}"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"var num_anons: usize = 0;"},
{"lineNum":"   33","line":"fn next_anon_name(class: []const u8, allocator: std.mem.Allocator) []const u8 {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   34","line":"    defer num_anons += 1;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   35","line":"    var out = std.array_list.Managed(u8).init(allocator);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   36","line":"    defer out.deinit();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   37","line":"    out.print(\"{s}__{}\", .{ class, num_anons }) catch unreachable;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   38","line":"    return out.toOwnedSlice() catch unreachable;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   39","line":"}"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"/// Converts imports to constant declarations"},
{"lineNum":"   42","line":"pub fn flat(self: Self, ast: *ast_.AST, asts: *std.array_list.Managed(*ast_.AST), idx: usize) walker_.Error!usize {","class":"lineCov","hits":"2","order":"1527","possible_hits":"2",},
{"lineNum":"   43","line":"    return self.import_flat(ast, asts, idx);","class":"lineCov","hits":"1","order":"1528","possible_hits":"1",},
{"lineNum":"   44","line":"}"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"fn import_flat(self: Self, ast: *ast_.AST, asts: *std.array_list.Managed(*ast_.AST), idx: usize) walker_.Error!usize {","class":"lineCov","hits":"2","order":"1529","possible_hits":"2",},
{"lineNum":"   47","line":"    if (ast.* != .import) {","class":"lineCov","hits":"1","order":"1530","possible_hits":"1",},
{"lineNum":"   48","line":"        return 0;","class":"lineCov","hits":"1","order":"1531","possible_hits":"1",},
{"lineNum":"   49","line":"    }"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"    if (ast.import.pattern.* == .pattern_symbol and ast.import.pattern.pattern_symbol.kind == .import) {","class":"lineCov","hits":"2","order":"5764","possible_hits":"2",},
{"lineNum":"   52","line":"        // Re-arrange to be a decl for the import"},
{"lineNum":"   53","line":"        const common = ast_.AST_Common{ ._token = ast.token() };","class":"lineCov","hits":"1","order":"5765","possible_hits":"1",},
{"lineNum":"   54","line":"        ast.* = ast_.AST{ .binding = .{"},
{"lineNum":"   55","line":"            .common = common,"},
{"lineNum":"   56","line":"            .pattern = ast.import.pattern,","class":"lineCov","hits":"3","order":"5766","possible_hits":"3",},
{"lineNum":"   57","line":"            .type = prelude_.unit_type,","class":"lineCov","hits":"1","order":"5767","possible_hits":"1",},
{"lineNum":"   58","line":"            .init = null,"},
{"lineNum":"   59","line":"            .decls = std.array_list.Managed(*ast_.AST).init(self.compiler.allocator()),","class":"lineCov","hits":"1","order":"5768","possible_hits":"1",},
{"lineNum":"   60","line":"        } };"},
{"lineNum":"   61","line":"        ast.binding.pattern.pattern_symbol.kind.import.real_symbol = try self.resolve_import(ast.binding.pattern);","class":"lineCov","hits":"2","order":"5769","possible_hits":"2",},
{"lineNum":"   62","line":"        return 0;","class":"lineCov","hits":"1","order":"5789","possible_hits":"1",},
{"lineNum":"   63","line":"    } else if (ast.import.pattern.* == .access) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   64","line":"        return self.unwrap_access_imports(ast, asts, idx);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   65","line":"    }"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"    return 0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   68","line":"}"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"/// Rewrites import access-sequences of the form:"},
{"lineNum":"   71","line":"///   import aaa::bbb::ccc"},
{"lineNum":"   72","line":"/// to:"},
{"lineNum":"   73","line":"///   import aaa as anon0"},
{"lineNum":"   74","line":"///   const anon1 = aaa::bbb"},
{"lineNum":"   75","line":"///   const ccc = anon1::ccc"},
{"lineNum":"   76","line":"fn unwrap_access_imports(self: Self, ast: *ast_.AST, asts: *std.array_list.Managed(*ast_.AST), idx: usize) !usize {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   77","line":"    var terms = self.create_terms(ast);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   78","line":"    defer terms.deinit();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"    var anon_names = self.create_anon_names(&terms);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   81","line":"    defer anon_names.deinit();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"    for (0.., terms.items) |i, term| {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   84","line":"        if (i < terms.items.len - 1) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   85","line":"            // Not the last term, these are just accesses on the i+1th term"},
{"lineNum":"   86","line":"            // Insert `const rhs = lhs::rhs`"},
{"lineNum":"   87","line":"            const init = ast_.AST.create_access(","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   88","line":"                ast.token(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   89","line":"                ast_.AST.create_identifier(Token.init_simple(anon_names.items[i + 1]), self.compiler.allocator()),","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   90","line":"                terms.items[i],","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   91","line":"                self.compiler.allocator(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   92","line":"            );"},
{"lineNum":"   93","line":"            const const_decl = ast_.AST.create_binding(","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   94","line":"                ast.import.pattern.token(),","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   95","line":"                ast_.AST.create_pattern_symbol(","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   96","line":"                    ast.token(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   97","line":"                    .import_inner,"},
{"lineNum":"   98","line":"                    .local,"},
{"lineNum":"   99","line":"                    anon_names.items[i],","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  100","line":"                    self.compiler.allocator(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  101","line":"                ),"},
{"lineNum":"  102","line":"                Type_AST.create_type_of(ast.token(), init, self.compiler.allocator()),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  103","line":"                init,"},
{"lineNum":"  104","line":"                self.compiler.allocator(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  105","line":"            );"},
{"lineNum":"  106","line":"            asts.insert(idx, const_decl) catch unreachable;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  107","line":"        } else {"},
{"lineNum":"  108","line":"            // The last term, this is the actual root module/package"},
{"lineNum":"  109","line":"            const common = ast_.AST_Common{ ._token = ast.token() };","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  110","line":"            ast.* = ast_.AST{ .binding = .{"},
{"lineNum":"  111","line":"                .common = common,"},
{"lineNum":"  112","line":"                .pattern = ast_.AST.create_pattern_symbol(","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  113","line":"                    ast.token(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  114","line":"                    .{ .import = .{ .real_name = term.token().data } },","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  115","line":"                    .local,"},
{"lineNum":"  116","line":"                    anon_names.items[i],","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  117","line":"                    self.compiler.allocator(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  118","line":"                ),"},
{"lineNum":"  119","line":"                .type = prelude_.unit_type,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  120","line":"                .init = null,"},
{"lineNum":"  121","line":"                .decls = std.array_list.Managed(*ast_.AST).init(self.compiler.allocator()),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  122","line":"            } };"},
{"lineNum":"  123","line":"            const symb = try self.resolve_import(ast.binding.pattern);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  124","line":"            symb.defined = true;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  125","line":"            ast.binding.pattern.pattern_symbol.kind.import.real_symbol = symb;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  126","line":"        }"},
{"lineNum":"  127","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"    return terms.items.len - 1;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  130","line":"}"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"/// Creates a list of terms from an access-sequence in reverse order."},
{"lineNum":"  133","line":"///"},
{"lineNum":"  134","line":"/// Turns:"},
{"lineNum":"  135","line":"/// ```"},
{"lineNum":"  136","line":"///   aaa::bbb::ccc"},
{"lineNum":"  137","line":"/// ```"},
{"lineNum":"  138","line":"/// into:"},
{"lineNum":"  139","line":"/// ```"},
{"lineNum":"  140","line":"///   [ccc, bbb, aaa]"},
{"lineNum":"  141","line":"/// ```"},
{"lineNum":"  142","line":"fn create_terms(self: Self, ast: *ast_.AST) std.array_list.Managed(*ast_.AST) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  143","line":"    var curr = ast.import.pattern;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  144","line":"    var terms = std.array_list.Managed(*ast_.AST).init(self.compiler.allocator());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"    while (curr.* == .access) : (curr = curr.lhs()) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  147","line":"        terms.append(curr.rhs()) catch unreachable;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  148","line":"    }"},
{"lineNum":"  149","line":"    terms.append(curr) catch unreachable;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  150","line":"    return terms;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  151","line":"}"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"/// Creates a list of anonymous names to use when unwrapping an access-sequence import, where the first is the actual"},
{"lineNum":"  154","line":"/// name, and every other is an anonymous name."},
{"lineNum":"  155","line":"///"},
{"lineNum":"  156","line":"/// Turns:"},
{"lineNum":"  157","line":"/// ```"},
{"lineNum":"  158","line":"///    [ccc, bbb, aaa]"},
{"lineNum":"  159","line":"/// ```"},
{"lineNum":"  160","line":"/// into:"},
{"lineNum":"  161","line":"/// ```"},
{"lineNum":"  162","line":"///    [ccc, anon0, anon1]"},
{"lineNum":"  163","line":"/// ```"},
{"lineNum":"  164","line":"fn create_anon_names(self: Self, terms: *std.array_list.Managed(*ast_.AST)) std.array_list.Managed([]const u8) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  165","line":"    var anon_names = std.array_list.Managed([]const u8).init(self.compiler.allocator());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  166","line":"    for (0.., terms.items) |i, term| {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  167","line":"        anon_names.append(","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  168","line":"            if (i == 0) term.token().data else next_anon_name(\"anon_import\", self.compiler.allocator()),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  169","line":"        ) catch unreachable;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  170","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  171","line":"    return anon_names;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  172","line":"}"},
{"lineNum":"  173","line":""},
{"lineNum":"  174","line":"/// Given an import pattern symbol `ast`, resolve the module symbol that it refers to, potentially compiling it if"},
{"lineNum":"  175","line":"/// necessary."},
{"lineNum":"  176","line":"fn resolve_import(self: Self, pattern_ast: *ast_.AST) walker_.Error!*Symbol {","class":"lineCov","hits":"2","order":"5770","possible_hits":"2",},
{"lineNum":"  177","line":"    std.debug.assert(pattern_ast.* == .pattern_symbol and pattern_ast.pattern_symbol.kind == .import);","class":"lineCov","hits":"2","order":"5771","possible_hits":"2",},
{"lineNum":"  178","line":"    const import_name = pattern_ast.pattern_symbol.kind.import.real_name;","class":"lineCov","hits":"3","order":"5772","possible_hits":"3",},
{"lineNum":"  179","line":"    const import_file_path = self.build_import_path(import_name);","class":"lineCov","hits":"1","order":"5773","possible_hits":"1",},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"    const import_symbol: *Symbol = try self.lookup_import_module(pattern_ast, import_name, import_file_path);","class":"lineCov","hits":"2","order":"5780","possible_hits":"2",},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"    self.local_imported_modules.put(import_symbol.init_value().?.module.module, void{}) catch unreachable;","class":"lineCov","hits":"2","order":"5787","possible_hits":"2",},
{"lineNum":"  184","line":"    return import_symbol;","class":"lineCov","hits":"1","order":"5788","possible_hits":"1",},
{"lineNum":"  185","line":"}"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"/// Constructs the absolute path of a hypothetical imported local module from the absolute path of this package and the import name"},
{"lineNum":"  188","line":"fn build_import_path(self: Self, import_name: []const u8) []const u8 {","class":"lineCov","hits":"2","order":"5774","possible_hits":"2",},
{"lineNum":"  189","line":"    var import_filename = std.array_list.Managed(u8).init(self.compiler.allocator());","class":"lineCov","hits":"1","order":"5775","possible_hits":"1",},
{"lineNum":"  190","line":"    defer import_filename.deinit();","class":"lineCov","hits":"1","order":"5779","possible_hits":"1",},
{"lineNum":"  191","line":"    import_filename.print(\"{s}.orng\", .{import_name}) catch unreachable;","class":"lineCov","hits":"2","order":"5776","possible_hits":"2",},
{"lineNum":"  192","line":"    const import_file_paths = [_][]const u8{ self.package_absolute_path, import_filename.items };","class":"lineCov","hits":"1","order":"5777","possible_hits":"1",},
{"lineNum":"  193","line":"    return std.fs.path.join(self.compiler.allocator(), &import_file_paths) catch unreachable;","class":"lineCov","hits":"2","order":"5778","possible_hits":"2",},
{"lineNum":"  194","line":"}"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"/// Looks up an import by name, returning the module symbol for either a foreign package or local module"},
{"lineNum":"  197","line":"fn lookup_import_module(self: Self, pattern_ast: *ast_.AST, import_name: []const u8, import_file_path: []const u8) walker_.Error!*Symbol {","class":"lineCov","hits":"2","order":"5781","possible_hits":"2",},
{"lineNum":"  198","line":"    if (self.compiler.lookup_package(self.package_absolute_path) != null and self.compiler.lookup_package_root_module(self.package_absolute_path, import_name) != null) {","class":"lineCov","hits":"1","order":"5782","possible_hits":"1",},
{"lineNum":"  199","line":"        // Foreign import of a package"},
{"lineNum":"  200","line":"        return self.compiler.lookup_package_root_module(self.package_absolute_path, import_name).?;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  201","line":"    } else {"},
{"lineNum":"  202","line":"        // Local import of a module"},
{"lineNum":"  203","line":"        return self.compiler.compile_module(import_file_path, null, false) catch |err| switch (err) {","class":"lineCov","hits":"3","order":"5783","possible_hits":"3",},
{"lineNum":"  204","line":"            error.FileNotFound => {"},
{"lineNum":"  205","line":"                self.compiler.errors.add_error(.{ .import_file_not_found = .{","class":"lineCov","hits":"2","order":"5794","possible_hits":"2",},
{"lineNum":"  206","line":"                    .filename = import_name,"},
{"lineNum":"  207","line":"                    .span = pattern_ast.token().span,","class":"lineCov","hits":"1","order":"5795","possible_hits":"1",},
{"lineNum":"  208","line":"                } });"},
{"lineNum":"  209","line":"                return error.CompileError;","class":"lineCov","hits":"1","order":"5796","possible_hits":"1",},
{"lineNum":"  210","line":"            },"},
{"lineNum":"  211","line":"            error.CompileError, error.ParseError, error.LexerError => {"},
{"lineNum":"  212","line":"                // This is possible if the user does `import Int` or something, or if there\'s lexer errors"},
{"lineNum":"  213","line":"                return error.CompileError;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  214","line":"            },"},
{"lineNum":"  215","line":"            else => std.debug.panic(\"compiler error: this shouldn\'t be reachable\\n\", .{}),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  216","line":"        };"},
{"lineNum":"  217","line":"    }"},
{"lineNum":"  218","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "orng-test", "date" : "2025-11-10 15:43:08", "instrumented" : 94, "covered" : 33,};
var merged_data = [];
